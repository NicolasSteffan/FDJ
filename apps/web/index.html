<!doctype html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>FDJ – Concours IA Euromillions</title>
    
    <!-- Styles CSS intégrés pour éviter les problèmes de chemins -->
    <!-- CSS LED Components - Conforme bible.md règle 3 -->
    <link rel="stylesheet" href="./led-components.css">
    
    <!-- API SQLite Backend -->
    <script src="sqlite-api.js"></script>
    <script src="csv-import.js"></script>
    <script src="force-data-demo.js"></script>
    <!-- CSS Switch Components - Conforme bible.md règle 3 -->
    <link rel="stylesheet" href="./switch-components.css">
    <!-- CSS Homepage Components - Conforme bible.md règle 3 -->
    <link rel="stylesheet" href="./homepage-components.css">
    <!-- CSS Lottery Components - Conforme bible.md règle 3 -->
    <link rel="stylesheet" href="./lottery-components.css">
    <!-- CSS Tirage Components - Conforme bible.md règle 3 -->
    <link rel="stylesheet" href="./tirage-components.css">
    <!-- CSS Tables Components - Conforme bible.md règle 3 -->
    <link rel="stylesheet" href="./tables-components.css">

    <style>
      /* Styles page d'accueil externalisés vers homepage-components.css - bible.md conforme */

      /* Boules de loterie externalisées vers lottery-components.css - bible.md conforme */

      /* Boutons et status externalisés vers homepage-components.css - bible.md conforme */

      /* Tables et sélecteurs externalisés vers tables-components.css - bible.md conforme */

      /* Page Tirage externalisée vers tirage-components.css - bible.md conforme */
      
      /* Styles interrupteur externalisés vers switch-components.css - bible.md conforme */
      

      

      

      
      /* Sections résultats et boules externalisées vers tirage-components.css et lottery-components.css - bible.md conforme */
      
      /* Page Scraping - Styles spécifiques */
      .scraping-mode-selector {
        display: flex;
        gap: 15px;
        margin-bottom: 10px;
      }
      
      .scraping-mode-selector label {
        display: flex;
        align-items: center;
        gap: 5px;
        color: #e6f0ff;
        cursor: pointer;
      }
      
      .date-range-controls {
        display: flex;
        gap: 10px;
        align-items: center;
      }
      
      .date-range-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      
      .date-range-group label {
        color: #e6f0ff;
        font-size: 12px;
      }
      
      .scraping-actions {
        display: flex;
        gap: 10px;
        align-items: center;
      }
      

      
      /* Styles pour le sélecteur de fichier source */
      .date-source-controls {
        margin-top: 15px;
        padding: 15px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.1);
      }
      
      .source-file-label {
        display: block;
        margin-bottom: 10px;
        color: #ecf0f1;
        font-size: 14px;
        font-weight: 500;
      }
      
      .source-file-container {
        display: flex;
        align-items: center;
        gap: 15px;
      }
      
      /* Bouton générique - Style unifié pour toute l'application */
      .btn-generic {
        background: rgba(155, 89, 182, 0.2);
        border: 1px solid #9b59b6;
        color: #9b59b6;
        padding: 8px 16px;
        font-size: 14px;
        min-width: 140px;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-family: inherit;
      }
      
      .btn-generic:hover {
        background: rgba(155, 89, 182, 0.3);
        border-color: #8e44ad;
        color: #8e44ad;
      }
      
      .btn-generic:active {
        background: rgba(155, 89, 182, 0.4);
        transform: translateY(1px);
      }
      
      .btn-generic:disabled {
        background: rgba(100, 100, 100, 0.2);
        border-color: #666;
        color: #666;
        cursor: not-allowed;
      }
      
      /* Style spécial pour le bouton fichier source (garde son icône) */
      .source-file-btn {
        background: rgba(155, 89, 182, 0.2);
        border-color: #9b59b6;
        color: #9b59b6;
        padding: 8px 16px;
        font-size: 14px;
        min-width: 140px;
      }
      
      .source-file-btn:hover {
        background: rgba(155, 89, 182, 0.3);
        border-color: #8e44ad;
        color: #8e44ad;
      }
      
      .source-file-name {
        color: #95a5a6;
        font-size: 13px;
        font-style: italic;
        flex: 1;
      }
      
      .source-file-name.selected {
        color: #2ecc71;
        font-style: normal;
        font-weight: 500;
      }
      
      .scraping-config {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      
      .config-row {
        display: flex;
        align-items: center;
        gap: 10px;
        justify-content: space-between;
      }
      
      .config-row label {
        color: #e6f0ff;
        min-width: 180px;
      }
      
      .config-row input[type="number"] {
        width: 100px;
        padding: 5px;
        border: 1px solid #3fb6ff;
        border-radius: 4px;
        background: rgba(0,0,0,0.3);
        color: #e6f0ff;
      }
      
      .config-row input[type="checkbox"] {
        margin-right: 8px;
      }
      
      .preview-stats, .progress-stats, .results-stats {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        margin-bottom: 20px;
      }
      
      .preview-stat, .stat-item, .result-stat {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      
      .stat-label {
        color: #888;
        font-size: 12px;
      }
      
      .stat-value {
        color: #e6f0ff;
        font-weight: bold;
      }
      
      .stat-value.success {
        color: #48bb78;
      }
      
      .stat-value.error {
        color: #f56565;
      }
      
      .dates-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      
      .date-tag {
        background: rgba(63, 182, 255, 0.2);
        border: 1px solid #3fb6ff;
        border-radius: 4px;
        padding: 4px 8px;
        font-size: 12px;
        color: #e6f0ff;
      }
      
      .date-tag.more {
        background: rgba(255, 165, 0, 0.2);
        border-color: #ffa500;
        color: #ffa500;
      }
      
      .progress-bar {
        width: 100%;
        height: 20px;
        background: rgba(0,0,0,0.3);
        border-radius: 10px;
        overflow: hidden;
        margin: 10px 0;
      }
      
      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #3fb6ff, #48bb78);
        transition: width 0.3s ease;
      }
      
      .progress-log {
        max-height: 200px;
        overflow-y: auto;
        background: rgba(0,0,0,0.3);
        border-radius: 4px;
        padding: 10px;
        font-family: monospace;
        font-size: 12px;
      }
      
      .log-entry {
        margin-bottom: 5px;
        display: flex;
        gap: 8px;
      }
      
      .log-time {
        color: #888;
        min-width: 80px;
      }
      
      .log-info {
        color: #e6f0ff;
      }
      
      .log-success {
        color: #48bb78;
      }
      
      .log-warning {
        color: #ffa500;
      }
      
      .log-error {
        color: #f56565;
      }
      
      /* Styles page Historique - Pagination */
      .historique-pagination {
        display: flex;
        align-items: center;
        gap: 15px;
        margin-top: 10px;
        flex-wrap: wrap;
      }
      
      .historique-navigation {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .nav-btn {
        min-width: 40px !important;
        padding: 6px 8px !important;
        font-size: 14px;
      }
      
      .nav-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        background: rgba(155, 89, 182, 0.1);
        border-color: rgba(155, 89, 182, 0.3);
        color: rgba(155, 89, 182, 0.5);
      }
      
      .page-info {
        color: #ecf0f1;
        font-size: 14px;
        font-weight: bold;
        margin: 0 8px;
      }

      /* Styles Configuration IA */
      .config-group {
        background: rgba(255, 255, 255, 0.05);
        padding: 15px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      
      .config-group h4 {
        color: #ecf0f1;
        margin: 0 0 10px 0;
        font-size: 16px;
      }
      
      .api-key-container input {
        background: rgba(155, 89, 182, 0.1) !important;
        border: 1px solid rgba(155, 89, 182, 0.3) !important;
        color: #ecf0f1 !important;
      }
      
      .api-key-container input:focus {
        border-color: #9b59b6 !important;
        outline: none;
        box-shadow: 0 0 5px rgba(155, 89, 182, 0.3);
      }
      
      /* Tous les styles CSS externalisés - BIBLE.MD CONFORME RÈGLE 3 */
      /* - Gains et tableaux → tirage-components.css et lottery-components.css */
      /* - Responsive → homepage-components.css et tirage-components.css */
    </style>
  </head>
  <body>
    <div class="background"></div>
    
    <header class="topbar">
      <canvas id="menuCanvas" aria-hidden="true"></canvas>
      <img id="logo" src="./assets/yesdata-logo.jpg" alt="YesData" />
      <div class="brand">YesData - EuroMillion</div>
      <nav class="menu">
        <ul class="menu-root">
          <li><a href="#" onclick="showSection('home')">Accueil</a></li>
          <li>
            <span class="menu-head">Tirages</span>
            <ul class="submenu">
              <li><a href="#" onclick="showSection('tirage')">Tirage</a></li>
              <li><a href="#" onclick="showHistorique()">Historique</a></li>
              <li><a href="#" onclick="showSection('scraping')">Scrapping</a></li>
            </ul>
          </li>
          <li>
            <span class="menu-head">IA</span>
            <ul class="submenu">
              <li><a href="#" onclick="showSection('ia-config')">Configuration</a></li>
            </ul>
          </li>
          <li>
            <span class="menu-head">Admin</span>
            <ul class="submenu">
              <li><a href="#" onclick="showSection('admin-diagnostic')">Diagnostic Base de données</a></li>
              <li><a href="#" onclick="showSection('admin-monitoring')">Monitoring Base de données</a></li>
              <li><a href="#" onclick="showSection('components')">Architecture - Documentation</a></li>
            </ul>
          </li>
        </ul>
      </nav>
    </header>

    <main class="content">
      <!-- Section Accueil -->
      <section id="home" class="section">
        <h1><span class="home-led"></span> Architecture OOP - FDJ EuroMillion</h1>
        
        <div class="status">
          <h3>✅ Système Opérationnel</h3>
          <p>Cette version fonctionne sans serveur et démontre l'architecture OOP refactorisée.</p>
        </div>

        <div class="demo-card">
          <h2>🏗️ Architecture Refactorisée</h2>
          <p>Le projet FDJ a été entièrement refactorisé en programmation orientée objet :</p>
          <ul>
            <li><strong>Modèles</strong> : Draw, Prediction, DataSource</li>
            <li><strong>Services</strong> : ScrapingService, DataService</li>
            <li><strong>Contrôleurs</strong> : DrawController, UIController</li>
            <li><strong>Composants</strong> : LotteryBall, Pagination, DataSourceSelector</li>
            <li><strong>Styles</strong> : CSS modulaires dans style/ClaudS4/</li>
          </ul>
        </div>

        <div class="demo-card">
          <h2>🔧 Fonctionnalités Disponibles</h2>
          <button onclick="showSection('demo')" class="btn-generic">Tester les Composants</button>
          <button onclick="showSection('components')" class="btn-generic">Voir les Éléments UI</button>
          <button onclick="testArchitecture()" class="btn-generic">Test Architecture</button>
        </div>
      </section>

      <!-- Section Démo -->
      <section id="demo" class="section hidden">
        <!-- Section Historique (non-pliable) -->
        <div class="historique-section">
          <div class="historique-header">
            <h2 class="historique-title">Historique</h2>
            
            <div class="historique-pagination">
              <label for="historiquePagination">Résultats par page :</label>
              <select id="historiquePagination" onchange="resetHistoriquePage()">
                <option value="10" selected>10</option>
                <option value="20">20</option>
                <option value="50">50</option>
                <option value="all">Tous</option>
              </select>
              
              <!-- Contrôles de navigation par pages -->
              <div class="historique-navigation" id="historiqueNavigation" style="display: none;">
                <button onclick="gotoHistoriquePage('first')" class="btn-generic nav-btn" title="Première page">
                  ⏮️
                </button>
                <button onclick="gotoHistoriquePage('prev')" class="btn-generic nav-btn" title="Page précédente">
                  ◀️
                </button>
                <span class="page-info" id="historiquePageInfo">Page 1 sur 1</span>
                <button onclick="gotoHistoriquePage('next')" class="btn-generic nav-btn" title="Page suivante">
                  ▶️
                </button>
                <button onclick="gotoHistoriquePage('last')" class="btn-generic nav-btn" title="Dernière page">
                  ⏭️
                </button>
              </div>
          </div>
        </div>

          <!-- Tableau des tirages sous forme de tags dépliables -->
          <div class="tirages-container" id="tiragesContainer">
            <p class="no-data-message">Aucun tirage en base de données. Effectuez d'abord un scraping depuis la page Tirage.</p>
            </div>
        </div>
      </section>

      <!-- Section Scraping -->
      <section id="scraping" class="section hidden">
        <h1><span class="tirage-led"></span> Scrapping</h1>

        <!-- Contrôles de Scraping -->
        <div class="tirage-controls">
          <!-- Ligne 1: Titres -->
          <div class="controls-titles">
            <div class="date-title-section">
              <h4>Mode de scraping</h4>
            </div>
            <div class="title-group">
              <h4>Configuration</h4>
            </div>
          </div>
          
          <!-- Ligne 2: Contrôles -->
          <div class="controls-row">
            <div class="date-load-group">
              <!-- Sélecteur de mode -->
              <div class="scraping-mode-selector">
                <label>
                  <input type="radio" name="scrapingMode" value="single" checked onchange="toggleScrapingMode()">
                  Date unique
                </label>
                <label>
                  <input type="radio" name="scrapingMode" value="range" onchange="toggleScrapingMode()">
                  Intervalle
                </label>
          </div>
              
              <!-- Contrôles date unique -->
              <div id="singleDateControls" class="date-controls-merged">
                <button onclick="changeScrapingDate(-1)" class="btn-generic">Précédent</button>
                <input type="date" id="scrapingDate" value="2025-08-13">
                <button onclick="changeScrapingDate(1)" class="btn-generic">Suivant</button>
        </div>

              <!-- Contrôles intervalle de dates -->
              <div id="rangeDateControls" class="date-range-controls" style="display: none;">
                <div class="date-range-group">
                  <label>De:</label>
                  <input type="date" id="scrapingDateFrom" value="2025-07-01" min="2004-01-01">
                </div>
                <div class="date-range-group">
                  <label>À:</label>
                  <input type="date" id="scrapingDateTo" value="2025-08-13">
                </div>
              </div>
            </div>
            
            <!-- Sélecteur de fichier source -->
            <div class="date-selection">
              <div class="date-source-controls">
                <label for="sourceFileSelector" class="source-file-label">📂 Import de données EuroMillions:</label>
                <div class="source-file-container">
                  <input type="file" id="sourceFileSelector" accept=".csv,.json,.txt" style="display: none;" onchange="handleSourceFileSelect(event)">
                  <button onclick="document.getElementById('sourceFileSelector').click()" class="load-btn source-file-btn">
                    📁 Fichier source
                  </button>
                  <span id="sourceFileName" class="source-file-name">Sélectionnez un fichier CSV EuroMillions</span>
                </div>
                <div style="margin-top: 8px; font-size: 12px; color: #95a5a6;">
                  💡 <strong>CSV automatique :</strong> Les fichiers .csv EuroMillions sont détectés et importés automatiquement<br/>
                  🎯 <strong>Format supporté :</strong> CSV officiel FDJ avec colonnes date, numéros, étoiles et gains
                </div>
              </div>
            </div>
            
            <!-- Actions de scraping -->
            <div class="toggle-switch">
              <div class="switch-container scraping-actions">
                <button onclick="startScraping()" class="btn-generic">
                  Lancer Scraping
                </button>
                
                <button onclick="stopScraping()" class="btn-generic" title="Arrêter le scraping en cours" style="display: none;" id="stopScrapingBtn">
                  Arrêter
                </button>
              </div>
            </div>
          </div>
          
          <!-- Ligne 3: Fil d'Ariane -->
          <div class="breadcrumb active" id="scrapingBreadcrumb">
            <div class="breadcrumb-content">
              <span class="breadcrumb-icon">🌐</span>
              <span class="breadcrumb-text" id="scrapingBreadcrumbText">Prêt pour le scraping</span>
            </div>
          </div>
        </div>

        <!-- Section Configuration (pliable) -->
        <div class="gains-section" id="scrapingConfigSection">
          <div class="gains-header" onclick="toggleScrapingConfig()">
            <h3><span class="led_generique_petite expanded" id="config-led"></span>Configuration avancée</h3>
            <span class="gains-toggle expanded" id="configToggle">▲</span>
          </div>
          <div class="gains-content expanded" id="configContent">
            <div class="scraping-config">
              <div class="config-row">
                <label for="scrapingDelay">Délai entre requests (ms):</label>
                <input type="number" id="scrapingDelay" value="1000" min="500" max="5000" step="100">
              </div>
              <div class="config-row">
                <label for="scrapingRetries">Nombre de tentatives:</label>
                <input type="number" id="scrapingRetries" value="3" min="1" max="10">
              </div>
              <div class="config-row">
                <label for="scrapingBatch">Taille des lots:</label>
                <input type="number" id="scrapingBatch" value="10" min="1" max="50">
              </div>
              <div class="config-row">
                <label>
                  <input type="checkbox" id="skipExisting" checked>
                  Ignorer les tirages déjà en base
                </label>
              </div>
            </div>
          </div>
        </div>



        <!-- Section Progrès (pliable) -->
        <div class="gains-section" id="scrapingProgressSection" style="display: none;">
          <div class="gains-header" onclick="toggleScrapingProgress()">
            <h3><span class="led_generique_petite expanded" id="progress-led"></span>Progrès du scraping</h3>
            <span class="gains-toggle expanded" id="progressToggle">▲</span>
          </div>
          <div class="gains-content expanded" id="progressContent">
            <div class="scraping-progress">
              <div class="progress-stats">
                <div class="stat-item">
                  <span class="stat-label">Progression:</span>
                  <span class="stat-value" id="progressPercent">0%</span>
                </div>
                <div class="stat-item">
                  <span class="stat-label">Traités:</span>
                  <span class="stat-value" id="progressProcessed">0</span>
                </div>
                <div class="stat-item">
                  <span class="stat-label">Réussis:</span>
                  <span class="stat-value" id="progressSuccess">0</span>
                </div>
                <div class="stat-item">
                  <span class="stat-label">Erreurs:</span>
                  <span class="stat-value" id="progressErrors">0</span>
                </div>
              </div>
              <div class="progress-bar">
                <div class="progress-fill" id="progressBar" style="width: 0%;"></div>
              </div>
              <div class="progress-log" id="progressLog">
                <!-- Logs de progression -->
              </div>
            </div>
          </div>
        </div>

        <!-- Section Résultats (pliable) -->
        <div class="gains-section" id="scrapingResultsSection" style="display: none;">
          <div class="gains-header" onclick="toggleScrapingResults()">
            <h3><span class="led_generique_petite expanded" id="results-led"></span>Résultats du scraping</h3>
            <span class="gains-toggle expanded" id="resultsToggle">▲</span>
          </div>
          <div class="gains-content expanded" id="resultsContent">
            <div class="scraping-results">
              <div id="scrapingResultsStats" class="results-stats">
                <!-- Statistiques des résultats -->
              </div>
              <div id="scrapingResultsList" class="results-list">
                <!-- Liste des tirages scrapés -->
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Section Tirage -->
      <section id="tirage" class="section hidden">
        <h1><span class="tirage-led"></span> Tirage</h1>

        <!-- Contrôles -->
        <div class="tirage-controls">
          <!-- Ligne 1: Titres -->
          <div class="controls-titles">
            <div class="date-title-section">
              <h4>Date de tirage</h4>
            </div>
            <div class="title-group">
              <h4>Source de données</h4>
            </div>
          </div>
          
          <!-- Ligne 2: Contrôles -->
          <div class="controls-row">
            <div class="date-load-group">
              <div class="date-controls-merged">
                <button onclick="changeDate(-1)" class="btn-generic">Précédent</button>
                <input type="date" id="drawDate" value="2025-08-13">
                <button onclick="changeDate(1)" class="btn-generic">Suivant</button>
              </div>
              
              <button onclick="loadDraw()" class="btn-generic">
                Charger
              </button>
              
              <button onclick="loadDrawForced()" class="btn-generic" title="Forcer un nouveau scraping même si en base">
                Force
              </button>
            </div>
            
            <div class="toggle-switch">
              <div class="switch-container">
                <span class="switch-label-left">Scrap</span>
                <div class="led_generique_petite expanded" id="scrapLed"></div>
                <div class="switch scrap">
                  <input type="checkbox" id="dataToggle" checked>
                  <span class="slider"></span>
                </div>
                <div class="led_generique_petite collapsed" id="jsonLed"></div>
                <span class="switch-label-right">Mock</span>
              </div>
            </div>
          </div>
          
          <!-- Ligne 3: Fil d'Ariane -->
          <div class="breadcrumb active" id="dataBreadcrumb">
            <div class="breadcrumb-content">
              <span class="breadcrumb-icon">🌐</span>
              <span class="breadcrumb-text">Source: Scrap (données réelles)</span>
            </div>
          </div>
        </div>

        <!-- Section Résultats (pliable) -->
        <div class="gains-section" id="resultsSection" style="display: none;">
          <div class="gains-header" onclick="toggleResults()">
            <h3><span class="led_generique_petite expanded" id="results-led"></span>Résultat</h3>
            <span class="gains-toggle expanded" id="resultsToggle"></span>
          </div>
          <div class="gains-content expanded" id="resultsContent">
            <div class="draw-result">
              <div class="draw-date" id="resultDate">Mardi 13 Août 2025</div>
              <div class="draw-balls" id="resultBalls">
                <!-- Les boules seront générées dynamiquement -->
              </div>
            </div>
          </div>
        </div>

        <!-- Section Gains (pliable) -->
        <div class="gains-section" id="gainsSection" style="display: none;">
          <div class="gains-header" onclick="toggleGains()">
            <h3><span class="led_generique_petite expanded" id="gains-led"></span>Gains et Répartitions</h3>
            <span class="gains-toggle expanded" id="gainsToggle"></span>
          </div>
          <div class="gains-content expanded" id="gainsContent">
            <table class="gains-table">
              <thead>
                <tr>
                  <th>Rang</th>
                  <th>Combinaison</th>
                  <th>Gagnants</th>
                  <th>Gain par gagnant</th>
                </tr>
              </thead>
              <tbody id="gainsTableBody">
                <!-- Données générées dynamiquement -->
              </tbody>
            </table>
          </div>
        </div>

        <div class="status" style="margin-top: 20px;">
          <p>💡 <strong>Utilisation :</strong> Sélectionnez une date, choisissez entre données simulées (Mock) ou scraping réel (Scrap), puis cliquez sur Charger pour afficher les résultats du tirage.</p>
        </div>
      </section>

      <!-- Section Statut -->
      <section id="status" class="section hidden">
        <h1>📊 Statut du Système</h1>

        <div class="status">
          <h3>✅ Version Opérationnelle</h3>
          <p>Cette version fonctionne avec ou sans serveur HTTP et démontre l'architecture refactorisée.</p>
        </div>



        <div class="demo-card">
          <h2>🚀 Pour utiliser la version serveur</h2>
          <ol>
            <li>Installez <strong>live-server</strong> : <code>npm install -g live-server</code></li>
            <li>Lancez le script : <code>go.bat</code></li>
            <li>Ou démarrez manuellement : <code>live-server --port=3010</code></li>
          </ol>
          <p><strong>URL serveur :</strong> <a href="http://localhost:3010" target="_blank">http://localhost:3010</a></p>
        </div>
      </section>

      <!-- Section Configuration IA -->
      <section id="ia-config" class="section hidden">
        <h1><span class="tirage-led"></span> Configuration IA</h1>

        <!-- Section OpenAI/ChatGPT -->
        <div class="gains-section tirage-tag collapsed" id="openai-section">
          <div class="gains-header tirage-tag-header" onclick="toggleTirageTag('openai-section')">
            <h3><span class="led_generique_petite collapsed" id="openai-led"></span>OpenAI / ChatGPT</h3>
            <span class="tirage-expand-arrow">▼</span>
          </div>
          <div class="tirage-tag-content" id="openaiContent">
            
            <!-- Clé API -->
            <div class="config-group" style="margin-bottom: 20px;">
              <h4>Clé API</h4>
              <div class="api-key-container" style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                <input type="password" id="openaiApiKey" placeholder="sk-..." 
                       style="flex: 1; padding: 8px; border: 1px solid #9b59b6; border-radius: 5px; background: rgba(155, 89, 182, 0.1); color: #ecf0f1;"
                       onchange="saveApiKey('openai', 'openaiApiKey')"
                       oninput="saveApiKey('openai', 'openaiApiKey')">
                <button onclick="toggleApiKeyVisibility('openaiApiKey')" class="btn-generic" style="min-width: 80px;">
                  Voir
                </button>
              </div>
              <p style="font-size: 12px; color: #95a5a6; margin-bottom: 15px;">
                Obtenez votre clé API sur <a href="https://platform.openai.com/api-keys" target="_blank" style="color: #3498db;">platform.openai.com</a>
              </p>
            </div>

            <!-- Configuration -->
            <div class="config-group" style="margin-bottom: 20px;">
              <h4>Configuration</h4>
              <div>
                <label style="display: block; margin-bottom: 5px; color: #ecf0f1;">Modèle:</label>
                <select id="openaiModel" class="btn-generic" style="width: 100%; text-align: left;" 
                        onchange="saveApiModel('openai', this.value)">
                  <option value="gpt-4o">GPT-4o (Recommandé)</option>
                  <option value="gpt-4o-mini">GPT-4o Mini</option>
                  <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                </select>
              </div>
            </div>

            <!-- Test de connexion -->
            <div class="config-group" style="margin-bottom: 20px;">
              <h4>Test de Connexion</h4>
              <button onclick="testOpenAIConnection()" class="btn-generic" style="margin-bottom: 10px;">
                Tester la Connexion
              </button>
              
              <!-- Zone de test API -->
              <div style="margin-top: 15px; padding: 10px; border: 1px solid #444; border-radius: 5px; background: rgba(0,0,0,0.2);">
                <label for="openaiTestInput" style="display: block; margin-bottom: 5px; color: #fff;">Question de test :</label>
                <textarea id="openaiTestInput" placeholder="Entrez votre question pour tester l'API OpenAI..." style="width: 100%; height: 60px; padding: 8px; border: 1px solid #666; border-radius: 4px; background: #2a2a2a; color: #fff; resize: vertical;">Quel est le 1er ministre de la France ?</textarea>
                
                <button onclick="sendOpenAITestQuestion()" class="btn-generic" style="margin-top: 10px; margin-bottom: 10px;">
                  Envoi
                </button>
                
                <label for="openaiTestResponse" style="display: block; margin-bottom: 5px; color: #fff;">Réponse :</label>
                <div id="openaiTestResponse" style="width: 100%; min-height: 100px; max-height: 300px; padding: 10px; border: 1px solid #666; border-radius: 4px; background: #1a1a1a; color: #fff; overflow-y: auto; font-family: monospace; font-size: 12px; white-space: pre-wrap;">Aucune réponse pour le moment...</div>
              </div>
              
              <div id="openaiTestResult" style="padding: 10px; border-radius: 5px; margin-top: 10px; display: none;"></div>
            </div>



          </div>
        </div>

        <!-- Section Claude/Anthropic -->
        <div class="gains-section tirage-tag collapsed" id="claude-section">
          <div class="gains-header tirage-tag-header" onclick="toggleTirageTag('claude-section')">
            <h3><span class="led_generique_petite collapsed" id="claude-led"></span>Claude / Anthropic</h3>
            <span class="tirage-expand-arrow">▼</span>
          </div>
          <div class="tirage-tag-content" id="claudeContent">
            
            <!-- Clé API -->
            <div class="config-group" style="margin-bottom: 20px;">
              <h4>Clé API</h4>
              <div class="api-key-container" style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                <input type="password" id="claudeApiKey" placeholder="sk-ant-..." 
                       style="flex: 1; padding: 8px; border: 1px solid #9b59b6; border-radius: 5px; background: rgba(155, 89, 182, 0.1); color: #ecf0f1;"
                       onchange="saveApiKey('claude', 'claudeApiKey')"
                       oninput="saveApiKey('claude', 'claudeApiKey')">
                <button onclick="toggleApiKeyVisibility('claudeApiKey')" class="btn-generic" style="min-width: 80px;">
                  Voir
                </button>
              </div>
              <p style="font-size: 12px; color: #95a5a6; margin-bottom: 15px;">
                Obtenez votre clé API sur <a href="https://console.anthropic.com/" target="_blank" style="color: #3498db;">console.anthropic.com</a>
              </p>
            </div>

            <!-- Configuration -->
            <div class="config-group" style="margin-bottom: 20px;">
              <h4>Configuration</h4>
              <div>
                <label style="display: block; margin-bottom: 5px; color: #ecf0f1;">Modèle:</label>
                <select id="claudeModel" class="btn-generic" style="width: 100%; text-align: left;"
                        onchange="saveApiModel('claude', this.value)">
                  <option value="claude-3-5-sonnet-20241022">Claude 3.5 Sonnet (Recommandé)</option>
                  <option value="claude-3-5-haiku-20241022">Claude 3.5 Haiku</option>
                  <option value="claude-3-opus-20240229">Claude 3 Opus</option>
                </select>
              </div>
            </div>

            <!-- Test de connexion -->
            <div class="config-group" style="margin-bottom: 20px;">
              <h4>Test de Connexion</h4>
              <button onclick="testClaudeConnection()" class="btn-generic" style="margin-bottom: 10px;">
                Tester la Connexion
              </button>
              
              <!-- Zone de test API -->
              <div style="margin-top: 15px; padding: 10px; border: 1px solid #444; border-radius: 5px; background: rgba(0,0,0,0.2);">
                <label for="claudeTestInput" style="display: block; margin-bottom: 5px; color: #fff;">Question de test :</label>
                <textarea id="claudeTestInput" placeholder="Entrez votre question pour tester l'API Claude..." style="width: 100%; height: 60px; padding: 8px; border: 1px solid #666; border-radius: 4px; background: #2a2a2a; color: #fff; resize: vertical;">Quel est le 1er ministre de la France ?</textarea>
                
                <button onclick="sendClaudeTestQuestion()" class="btn-generic" style="margin-top: 10px; margin-bottom: 10px;">
                  Envoi
                </button>
                
                <label for="claudeTestResponse" style="display: block; margin-bottom: 5px; color: #fff;">Réponse :</label>
                <div id="claudeTestResponse" style="width: 100%; min-height: 100px; max-height: 300px; padding: 10px; border: 1px solid #666; border-radius: 4px; background: #1a1a1a; color: #fff; overflow-y: auto; font-family: monospace; font-size: 12px; white-space: pre-wrap;">Aucune réponse pour le moment...</div>
              </div>
              
              <div id="claudeTestResult" style="padding: 10px; border-radius: 5px; margin-top: 10px; display: none;"></div>
            </div>



          </div>
        </div>

        <!-- Section Mistral AI -->
        <div class="gains-section tirage-tag collapsed" id="mistral-section">
          <div class="gains-header tirage-tag-header" onclick="toggleTirageTag('mistral-section')">
            <h3><span class="led_generique_petite collapsed" id="mistral-led"></span>Mistral AI</h3>
            <span class="tirage-expand-arrow">▼</span>
          </div>
          <div class="tirage-tag-content" id="mistralContent">
            
            <!-- Clé API -->
            <div class="config-group" style="margin-bottom: 20px;">
              <h4>Clé API</h4>
              <div class="api-key-container" style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                <input type="password" id="mistralApiKey" placeholder="..." 
                       style="flex: 1; padding: 8px; border: 1px solid #9b59b6; border-radius: 5px; background: rgba(155, 89, 182, 0.1); color: #ecf0f1;"
                       onchange="saveApiKey('mistral', 'mistralApiKey')"
                       oninput="saveApiKey('mistral', 'mistralApiKey')">
                <button onclick="toggleApiKeyVisibility('mistralApiKey')" class="btn-generic" style="min-width: 80px;">
                  Voir
                </button>
              </div>
              <p style="font-size: 12px; color: #95a5a6; margin-bottom: 15px;">
                Obtenez votre clé API sur <a href="https://console.mistral.ai/" target="_blank" style="color: #3498db;">console.mistral.ai</a>
              </p>
            </div>

            <!-- Configuration -->
            <div class="config-group" style="margin-bottom: 20px;">
              <h4>Configuration</h4>
              <div>
                <label style="display: block; margin-bottom: 5px; color: #ecf0f1;">Modèle:</label>
                <select id="mistralModel" class="btn-generic" style="width: 100%; text-align: left;"
                        onchange="saveApiModel('mistral', this.value)">
                  <option value="mistral-small-latest">Mistral Small</option>
                  <option value="pixtral-12b-2409">Magistral Small</option>
                  <option value="mistral-3b-latest">Mistral 3B</option>
                </select>
              </div>
            </div>

            <!-- Test de connexion -->
            <div class="config-group" style="margin-bottom: 20px;">
              <h4>Test de Connexion</h4>
              <button onclick="testMistralConnection()" class="btn-generic" style="margin-bottom: 10px;">
                Tester la Connexion
              </button>
              
              <!-- Zone de test API -->
              <div style="margin-top: 15px; padding: 10px; border: 1px solid #444; border-radius: 5px; background: rgba(0,0,0,0.2);">
                <label for="mistralTestInput" style="display: block; margin-bottom: 5px; color: #fff;">Question de test :</label>
                <textarea id="mistralTestInput" placeholder="Entrez votre question pour tester l'API Mistral..." style="width: 100%; height: 60px; padding: 8px; border: 1px solid #666; border-radius: 4px; background: #2a2a2a; color: #fff; resize: vertical;">Quel est le 1er ministre de la France ?</textarea>
                
                <button onclick="sendMistralTestQuestion()" class="btn-generic" style="margin-top: 10px; margin-bottom: 10px;">
                  Envoi
                </button>
                
                <label for="mistralTestResponse" style="display: block; margin-bottom: 5px; color: #fff;">Réponse :</label>
                <div id="mistralTestResponse" style="width: 100%; min-height: 100px; max-height: 300px; padding: 10px; border: 1px solid #666; border-radius: 4px; background: #1a1a1a; color: #fff; overflow-y: auto; font-family: monospace; font-size: 12px; white-space: pre-wrap;">Aucune réponse pour le moment...</div>
              </div>
              
              <div id="mistralTestResult" style="padding: 10px; border-radius: 5px; margin-top: 10px; display: none;"></div>
            </div>



          </div>
        </div>

        <!-- Statut général -->
        <div class="status" style="margin-top: 20px;">
          <p><strong>Information :</strong> Les clés API sont stockées localement dans votre navigateur et ne sont jamais transmises à nos serveurs.</p>
          <p><strong>Sécurité :</strong> Vos données restent privées et les appels API sont effectués directement depuis votre navigateur.</p>
        </div>

      </section>

      <!-- Section Admin - Diagnostic Base -->
      <section id="admin-diagnostic" class="section hidden">
        <h1>🔍 Admin - Diagnostic Base de Données</h1>
        
        <div class="demo-card">
          <h2>📊 Vue d'ensemble</h2>
          <div id="diagnostic-stats"></div>
          <button onclick="loadDatabaseDiagnostic()" class="btn-generic">Actualiser</button>
        </div>

        <div class="demo-card">
          <h2>📋 Données Stockées</h2>
          <div id="diagnostic-details"></div>
        </div>

        <div class="demo-card">
          <h2>🛠️ Actions</h2>
          <button onclick="clearDatabase()" class="btn-generic">
            Vider la Base
          </button>
          <button onclick="exportDatabase()" class="btn-generic">
            Exporter
          </button>
        </div>
      </section>

      <!-- Section Admin - Monitoring Base -->
      <section id="admin-monitoring" class="section hidden">
        <h1>Admin - Monitoring Base de Données</h1>
        
        <!-- Section 1: Dump SQLite (hauteur fixe) -->
        <div class="tirage-tag collapsed" id="sqlite-dump-main-tag">
          <div class="tirage-tag-header" onclick="toggleTirageTag('sqlite-dump-main-tag')">
            <h2>
              <span class="led_generique_petite collapsed" id="sqlite-dump-main-led"></span>
              Dump
            </h2>
            <span class="tirage-expand-arrow">▼</span>
          </div>
          <div class="tirage-tag-content">
            <div style="margin-bottom: 10px;">
              <button onclick="clearDumpLog()" class="btn-generic" style="font-size: 10px;">Clear</button>
            </div>
            <div id="sqlite-dump-content" style="background: #1a1a1a; padding: 15px; border-radius: 4px; font-family: monospace; font-size: 12px; color: #00ff00; height: 200px; overflow-y: auto;">
              <div style="color: #ffff00; margin-bottom: 10px;">📡 SQLite Backend Connection Tracer</div>
              <div>yesdata</div>
              <div style="color: #888; margin-top: 10px;">Attente connexions...</div>
            </div>
          </div>
        </div>

        <!-- Section 2: SQLite Backend - Connexion & Tests -->
        <div class="tirage-tag collapsed" id="sqlite-backend-main-tag">
          <div class="tirage-tag-header" onclick="toggleTirageTag('sqlite-backend-main-tag')">
            <h2>
              <span class="led_generique_petite collapsed" id="sqlite-backend-main-led"></span>
              SQLite Backend
            </h2>
            <span class="tirage-expand-arrow">▼</span>
          </div>
          <div class="tirage-tag-content">


          <!-- Sous-section 1: Install from Scratch (pliable) -->
          <div class="tirage-tag collapsed" id="sqlite-install-tirage-tag">
            <div class="tirage-tag-header" onclick="toggleTirageTag('sqlite-install-tirage-tag')">
              <h2>
                <span class="led_generique_petite collapsed" id="sqlite-install-led"></span>
                Install from Scratch
              </h2>
              <span class="tirage-expand-arrow">▼</span>
            </div>
            <div class="tirage-tag-content">
              <div class="install-section">
                <div class="install-warning">
                  <h4>⚠️ Installation complète de la base SQLite</h4>
                  <p>Cette action va :</p>
                  <ul>
                    <li>🗑️ Supprimer complètement la base existante</li>
                    <li>🏗️ Recréer toutes les tables (tirages, gains, sources, config)</li>
                    <li>📊 Ajouter les index de performance</li>
                    <li>🎲 Insérer des données de démonstration</li>
                  </ul>
                  <p><strong>⚠️ Attention :</strong> Toutes les données existantes seront perdues !</p>
                </div>
                
                <div class="install-actions">
                  <button class="btn-generic" onclick="clearAllDatabaseData()">
                    effacer le données
                  </button>
                  <button class="btn-generic" onclick="installFreshDatabase()">
                    Installation Complète
                  </button>
                  <button class="btn-generic" onclick="checkDatabaseStatus()">
                    Vérifier État
                  </button>
                </div>
                
                <div id="install-logs" class="install-logs">
                  <div class="logs-header">📋 Logs d'installation :</div>
                  <div id="install-logs-content" class="logs-content">
                    Prêt pour installation...
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Sous-section 1: Test par fonction SQLite (pliable) -->
          <div class="tirage-tag collapsed" id="sqlite-test-tirage-tag">
            <div class="tirage-tag-header" onclick="toggleTirageTag('sqlite-test-tirage-tag')">
              <h2>
                <span class="led_generique_petite collapsed" id="sqlite-test-led"></span>
                Test par fonction
              </h2>
              <span class="tirage-expand-arrow">▼</span>
            </div>
            <div class="tirage-tag-content">
              <!-- Tags de test avec LED pour chaque étape -->
              <div class="test-tags-container">
                
                <!-- Tag: Test Connexion -->
                <div class="test-tag" id="test-connection-tag">
                  <span class="led_generique_petite collapsed" id="test-connection-led"></span>
                  <span class="test-label">Connexion SQLite</span>
                  <button class="btn-generic" onclick="testSQLiteBackendConnectionUI()">Tester</button>
                </div>
                
                <!-- Tag: Test Base -->
                <div class="test-tag" id="test-database-tag">
                  <span class="led_generique_petite collapsed" id="test-database-led"></span>
                  <span class="test-label">Base de données</span>
                  <button class="btn-generic" onclick="testSQLiteBackendDatabase()">Tester</button>
                  <button class="btn-generic" onclick="createDatabaseUI()">Installation Complète</button>
                </div>
                
                <!-- Tag: Test Tables -->
                <div class="test-tag" id="test-tables-tag">
                  <span class="led_generique_petite collapsed" id="test-tables-led"></span>
                  <span class="test-label">Tables (tirages)</span>
                  <button class="btn-generic" onclick="testSQLiteBackendTables()">Tester</button>
                </div>
                
                <!-- Tag: Test Insert -->
                <div class="test-tag" id="test-insert-tag">
                  <span class="led_generique_petite collapsed" id="test-insert-led"></span>
                  <span class="test-label">Insert données</span>
                  <button class="btn-generic" onclick="testSQLiteBackendInsert()">Tester</button>
                </div>
                
                <!-- Tag: Test Select -->
                <div class="test-tag" id="test-select-tag">
                  <span class="led_generique_petite collapsed" id="test-select-led"></span>
                  <span class="test-label">Select données</span>
                  <button class="btn-generic" onclick="testSQLiteBackendSelect()">Tester</button>
                </div>
                
                <!-- Tag: Effacer données -->
                <div class="test-tag" id="test-clear-data-tag">
                  <span class="led_generique_petite collapsed" id="test-clear-data-led"></span>
                  <span class="test-label">Effacer données</span>
                  <button class="btn-generic" onclick="clearAllDatabaseData()">Effacer tout</button>
                </div>
                
              </div>
            </div>
          </div>

          </div>
        </div>

        <!-- Section 3: Monitoring Tables -->
        <div class="tirage-tag collapsed" id="sqlite-monitoring-main-tag">
          <div class="tirage-tag-header" onclick="toggleTirageTag('sqlite-monitoring-main-tag')">
            <h2>
              <span class="led_generique_petite collapsed" id="sqlite-monitoring-main-led"></span>
              Monitoring Tables
            </h2>
            <span class="tirage-expand-arrow">▼</span>
          </div>
          <div class="tirage-tag-content">
            <!-- Contrôles de sélection -->
            <div class="selector-group" style="margin-bottom: 20px;">
              <label for="sqliteTableSelector">Table à surveiller :</label>
              <select id="sqlite-table-select" onchange="autonomousBackendTableMonitoring()">
                <option value="">-- Sélectionner une table --</option>
                <option value="tirages">Tirages (tirages)</option>
                <option value="gains">Gains (gains)</option>
                <option value="sources">Sources (sources)</option>
                <option value="config">Configuration (config)</option>
                <option value="all">Toutes les données</option>
              </select>
            </div>
            
            <div class="selector-group" style="margin-bottom: 20px;">
              <label for="sqlitePageSize">Résultats par page :</label>
              <select id="sqlitePageSize" onchange="autonomousBackendTableMonitoring()">
                <option value="10" selected>10</option>
                <option value="20">20</option>
                <option value="50">50</option>
              </select>
            </div>
            
            <!-- Statut de connexion automatique -->
            <div id="sqlite-auto-status" style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px; display: none;">
              <div id="sqlite-auto-logs"></div>
            </div>
            
            <!-- Données et statistiques -->
            <div id="sqlite-monitoring-stats">
              <p style="color: #888; text-align: center; padding: 20px;">
                Sélectionnez une table pour voir les données
              </p>
            </div>
            <div id="sqlite-monitoring-table"></div>
            <div id="sqlite-monitoring-pagination"></div>
          </div>
        </div>


      </section>
    </main>

    <!-- Mock Data pour les tirages -->
    <script src="./mock-data.js"></script>

    <!-- JavaScript intégré pour éviter les problèmes de modules ES6 -->
    <script>
      // Navigation entre sections
      function showSection(sectionId) {
        const sections = document.querySelectorAll('.section');
        sections.forEach(section => section.classList.add('hidden'));
        document.getElementById(sectionId).classList.remove('hidden');
        
        // Initialiser les sections spéciales
        if (sectionId === 'admin-diagnostic') {
          loadDatabaseDiagnostic();
        } else if (sectionId === 'admin-monitoring') {
          clearDumpLog();
          initializeMonitoringLEDs();
          loadTableData();
          // Initialiser l'affichage du monitoring SQLite
          if (typeof clearMonitoringDisplay === 'function') {
            clearMonitoringDisplay();
          }
        }
      }

      // Générateur de tirage aléatoire
      function generateRandomDraw() {
        const ballsContainer = document.querySelector('.balls');
        ballsContainer.innerHTML = '';
        
        // Générer 5 numéros uniques entre 1 et 50
        const numbers = [];
        while (numbers.length < 5) {
          const num = Math.floor(Math.random() * 50) + 1;
          if (!numbers.includes(num)) numbers.push(num);
        }
        numbers.sort((a, b) => a - b);
        
        // Générer 2 étoiles uniques entre 1 et 12
        const stars = [];
        while (stars.length < 2) {
          const star = Math.floor(Math.random() * 12) + 1;
          if (!stars.includes(star)) stars.push(star);
        }
        stars.sort((a, b) => a - b);
        
        // Afficher les numéros
        numbers.forEach(num => {
          const ball = document.createElement('div');
          ball.className = 'ball';
          ball.textContent = num;
          ballsContainer.appendChild(ball);
        });
        
        // Afficher les étoiles
        stars.forEach(star => {
          const ball = document.createElement('div');
          ball.className = 'ball star';
          ball.textContent = star;
          ballsContainer.appendChild(ball);
        });
      }

      // Changement de source de données
      function switchDataSource(source) {
        const status = document.getElementById('sourceStatus');
        if (source === 'json') {
          status.textContent = 'Source active : Fichiers JSON';
        } else {
          status.textContent = 'Source active : Base de données SQLite';
        }
      }

      // Ajouter une ligne au tableau
      function addRandomRow() {
        const tbody = document.getElementById('drawsTable');
        const row = document.createElement('tr');
        
        const date = new Date().toLocaleDateString('fr-FR');
        
        // Générer des numéros aléatoires
        const numbers = [];
        while (numbers.length < 5) {
          const num = Math.floor(Math.random() * 50) + 1;
          if (!numbers.includes(num)) numbers.push(num);
        }
        numbers.sort((a, b) => a - b);
        
        const stars = [];
        while (stars.length < 2) {
          const star = Math.floor(Math.random() * 12) + 1;
          if (!stars.includes(star)) stars.push(star);
        }
        stars.sort((a, b) => a - b);
        
        row.innerHTML = `
          <td>${date}</td>
          <td>${numbers.join(', ')}</td>
          <td>${stars.join(', ')}</td>
          <td>Généré</td>
        `;
        
        tbody.appendChild(row);
      }

      // Test de l'architecture
      function testArchitecture() {
        alert('🎉 Architecture OOP Testée!\n\n' +
              '✅ Modèles : Draw, Prediction, DataSource\n' +
              '✅ Services : ScrapingService, DataService\n' +
              '✅ Contrôleurs : DrawController, UIController\n' +
              '✅ Composants : LotteryBall, Pagination\n' +
              '✅ Styles : CSS modulaires séparés\n\n' +
              'Toutes les règles de la bible.md sont respectées !');
      }

      // Fonctions pour l'historique des tirages
      function showHistorique() {
        showSection('demo');
        loadHistoriqueMock();
      }

      function loadHistoriqueMock() {
        const tbody = document.getElementById('drawsTable');
        const historique = window.mockEuroMillion.getHistorique();
        
        console.log('📊 Chargement historique Mock:', historique.length, 'tirages');
        
        // Vider le tableau
        tbody.innerHTML = '';
        
        // Afficher les 10 derniers tirages
        const recentDraws = historique.slice(-10).reverse(); // Les 10 plus récents, du plus récent au plus ancien
        
        recentDraws.forEach(draw => {
          const row = document.createElement('tr');
          
          // Date
          const dateCell = document.createElement('td');
          dateCell.textContent = draw.date;
          row.appendChild(dateCell);
          
          // Numéros
          const numbersCell = document.createElement('td');
          numbersCell.textContent = draw.numbers.join(', ');
          row.appendChild(numbersCell);
          
          // Étoiles
          const starsCell = document.createElement('td');
          starsCell.innerHTML = `<span style="color: var(--accent);">${draw.stars.join(', ')}</span>`;
          row.appendChild(starsCell);
          
          // Source
          const sourceCell = document.createElement('td');
          sourceCell.innerHTML = '<span style="color: #00e1ff;">Mock</span>';
          row.appendChild(sourceCell);
          
          tbody.appendChild(row);
        });
        
        console.log('✅ Historique Mock affiché:', recentDraws.length, 'tirages');
      }

      // Diagnostic du système
      // === FONCTIONS ADMIN ===
      
      // Charger le diagnostic de la base de données
      function loadDatabaseDiagnostic() {
        const stats = document.getElementById('diagnostic-stats');
        const details = document.getElementById('diagnostic-details');
        
        // Statistiques
        const totalKeys = Object.keys(localStorage).length;
        const drawKeys = Object.keys(localStorage).filter(key => key.startsWith('draw_'));
        const otherKeys = Object.keys(localStorage).filter(key => !key.startsWith('draw_'));
        
        stats.innerHTML = `
          <div class="stats-grid">
            <div class="stat-card">
              <h4 style="color: #00ff00;">🎯 Tirages</h4>
              <p style="color: #00ff00;">${drawKeys.length}</p>
            </div>
            <div class="stat-card">
              <h4 style="color: #ffa500;">📊 Autres Données</h4>
              <p style="color: #ffa500;">${otherKeys.length}</p>
            </div>
            <div class="stat-card">
              <h4 style="color: #00bfff;">🗄️ Total Clés</h4>
              <p style="color: #00bfff;">${totalKeys}</p>
            </div>
          </div>
        `;
        
        // Détails des tirages
        if (drawKeys.length > 0) {
          let detailsHtml = `
            <h4>📋 Tirages stockés (${drawKeys.length} au total)</h4>
            <div style="max-height: 300px; overflow-y: auto; border: 1px solid rgba(255,255,255,0.2); border-radius: 5px; padding: 10px;">
          `;
          
          drawKeys.sort().slice(-10).forEach(key => {
            const data = JSON.parse(localStorage.getItem(key));
            const date = key.replace('draw_', '');
            detailsHtml += `
              <div style="border-bottom: 1px solid rgba(255,255,255,0.1); padding: 8px 0;">
                <strong>${date}</strong> - ${data.source || 'Unknown'} 
                ${data.numbers ? `(${data.numbers.join(',')})` : ''}
                <span style="color: #888; font-size: 0.9em;">${data.gains?.length || 0} gains</span>
              </div>
            `;
          });
          
          detailsHtml += '</div>';
          details.innerHTML = detailsHtml;
        } else {
          details.innerHTML = '<p>Aucun tirage stocké en base de données.</p>';
        }
      }
      
      // Vider la base de données
      function clearDatabase() {
        if (confirm('⚠️ Êtes-vous sûr de vouloir vider toute la base de données ? Cette action est irréversible.')) {
          localStorage.clear();
          loadDatabaseDiagnostic();
          alert('✅ Base de données vidée avec succès.');
        }
      }
      
      // Exporter la base de données
      function exportDatabase() {
        const data = {};
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          data[key] = JSON.parse(localStorage.getItem(key));
        }
        
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `fdj_database_export_${new Date().toISOString().slice(0,10)}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      
      // === MONITORING ===
      let currentPage = 1;
      let currentData = [];
      
      // Charger les données de la table sélectionnée
      function loadTableData() {
        const tableType = document.getElementById('tableSelector').value;
        const pageSize = parseInt(document.getElementById('pageSize').value);
        
        currentPage = 1; // Reset à la page 1
        currentData = getAllTableData(tableType);
        displayTableData(currentData, pageSize, currentPage, tableType);
      }
      
      // Récupérer toutes les données selon le type de table
      function getAllTableData(tableType) {
        const data = [];
        
        if (tableType === 'draws' || tableType === 'all') {
          // Récupérer tous les tirages
          Object.keys(localStorage).filter(key => key.startsWith('draw_')).forEach(key => {
            const drawData = JSON.parse(localStorage.getItem(key));
            const date = key.replace('draw_', '');
            data.push({
              type: 'draw',
              date: date,
              numbers: drawData.numbers?.join(', ') || 'N/A',
              stars: drawData.stars?.join(', ') || 'N/A',
              source: drawData.source || 'Unknown',
              gains: drawData.gains?.length || 0
            });
          });
        }
        
        if (tableType === 'gains' || tableType === 'all') {
          // Récupérer tous les gains de tous les tirages
          Object.keys(localStorage).filter(key => key.startsWith('draw_')).forEach(key => {
            const drawData = JSON.parse(localStorage.getItem(key));
            const date = key.replace('draw_', '');
            if (drawData.gains) {
              drawData.gains.forEach(gain => {
                data.push({
                  type: 'gain',
                  date: date,
                  rang: gain.rang || gain.rankLabel || 'N/A',
                  gagnants: gain.gagnants || gain.winners || 0,
                  gain: gain.gain || gain.amount || 'N/A',
                  source: drawData.source || 'Unknown'
                });
              });
            }
          });
        }
        
        return data.sort((a, b) => b.date.localeCompare(a.date));
      }
      
      // Afficher les données dans un tableau avec pagination
      function displayTableData(data, pageSize, page, tableType) {
        const stats = document.getElementById('monitoring-stats');
        const tableDiv = document.getElementById('monitoring-table');
        const pagination = document.getElementById('monitoring-pagination');
        
        // Statistiques
        stats.innerHTML = `<strong>Total: ${data.length} entrées</strong> | Page ${page} sur ${Math.ceil(data.length / pageSize)}`;
        
        // Données paginées
        const startIndex = (page - 1) * pageSize;
        const endIndex = startIndex + pageSize;
        const pageData = data.slice(startIndex, endIndex);
        
        // Créer le tableau
        let tableHtml = '<table style="width: 100%; border-collapse: collapse; margin-top: 10px;">';
        
        // Headers selon le type
        if (tableType === 'draws') {
          tableHtml += '<tr style="background: rgba(255,255,255,0.1);"><th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Date</th><th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Numéros</th><th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Étoiles</th><th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Source</th><th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Gains</th></tr>';
          pageData.forEach(item => {
            tableHtml += `<tr><td style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">${item.date}</td><td style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">${item.numbers}</td><td style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">${item.stars}</td><td style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">${item.source}</td><td style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">${item.gains}</td></tr>`;
          });
        } else if (tableType === 'gains') {
          tableHtml += '<tr style="background: rgba(255,255,255,0.1);"><th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Date Tirage</th><th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Rang</th><th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Gagnants</th><th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Montant</th><th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Source</th></tr>';
          pageData.forEach(item => {
            tableHtml += `<tr><td style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">${item.date}</td><td style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">${item.rang}</td><td style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">${item.gagnants}</td><td style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">${item.gain}</td><td style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">${item.source}</td></tr>`;
          });
        } else { // all
          tableHtml += '<tr style="background: rgba(255,255,255,0.1);"><th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Type</th><th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Date</th><th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Données</th><th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Source</th></tr>';
          pageData.forEach(item => {
            const dataText = item.type === 'draw' ? `${item.numbers} | ${item.stars}` : `${item.rang} - ${item.gagnants} gagnants`;
            tableHtml += `<tr><td style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">${item.type}</td><td style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">${item.date}</td><td style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">${dataText}</td><td style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">${item.source}</td></tr>`;
          });
        }
        
        tableHtml += '</table>';
        tableDiv.innerHTML = tableHtml;
        
        // Pagination
        const totalPages = Math.ceil(data.length / pageSize);
        let paginationHtml = '';
        
        if (totalPages > 1) {
          paginationHtml += '<div style="display: flex; gap: 10px; align-items: center; justify-content: center;">';
          
          if (page > 1) {
            paginationHtml += `<button onclick="changePage(${page - 1})" class="btn-generic">Précédent</button>`;
          }
          
          paginationHtml += `<span>Page ${page} sur ${totalPages}</span>`;
          
          if (page < totalPages) {
            paginationHtml += `<button onclick="changePage(${page + 1})" class="btn-generic">Suivant</button>`;
          }
          
          paginationHtml += '</div>';
        }
        
        pagination.innerHTML = paginationHtml;
      }
      
      // Changer de page
      function changePage(newPage) {
        const pageSize = parseInt(document.getElementById('pageSize').value);
        const tableType = document.getElementById('tableSelector').value;
        currentPage = newPage;
        displayTableData(currentData, pageSize, currentPage, tableType);
      }
      
      // === GESTION SECTIONS PLIABLES MONITORING ===
      
      // État des sections (par défaut toutes déployées)
      const monitoringSections = {
        selection: true, // true = déployé, false = plié
        data: true
      };
      
      // Basculer l'état d'une section
      function toggleMonitoringSection(sectionName) {
        const content = document.getElementById(sectionName + '-content');
        const led = document.getElementById(sectionName + '-led');
        const arrow = document.getElementById(sectionName + '-arrow');
        
        // Basculer l'état
        monitoringSections[sectionName] = !monitoringSections[sectionName];
        
        if (monitoringSections[sectionName]) {
          // Déplier
          content.classList.remove('collapsed');
          content.classList.add('expanded');
          led.classList.remove('collapsed');
          led.classList.add('expanded');
          arrow.classList.remove('collapsed');
          arrow.classList.add('expanded');
        } else {
          // Plier
          content.classList.remove('expanded');
          content.classList.add('collapsed');
          led.classList.remove('expanded');
          led.classList.add('collapsed');
          arrow.classList.remove('expanded');
          arrow.classList.add('collapsed');
        }
      }
      
      // Initialiser l'état des LEDs pour la page Admin Monitoring
      function initializeMonitoringLEDs() {
        console.log('🔧 Initialisation des LEDs Admin Monitoring');
        
        // LEDs des sections principales (SQLite) - Maintenant collapsed par défaut
        const mainLeds = [
          {id: 'sqlite-dump-main-led', defaultState: 'collapsed'},
          {id: 'sqlite-backend-main-led', defaultState: 'collapsed'},
          {id: 'sqlite-monitoring-main-led', defaultState: 'collapsed'}
        ];
        mainLeds.forEach(ledInfo => {
          const led = document.getElementById(ledInfo.id);
          if (led) {
            led.classList.remove('collapsed', 'expanded');
            led.classList.add(ledInfo.defaultState);
          }
        });
        
        // LEDs des sous-sections - Initialiser selon l'état de leur section parent
        const subLeds = [
          {id: 'sqlite-install-led', defaultState: 'collapsed'},
          {id: 'sqlite-persistance-led', defaultState: 'collapsed'},
          {id: 'sqlite-dump-led', defaultState: 'collapsed'},
          {id: 'sqlite-test-led', defaultState: 'collapsed'},
          {id: 'sqlite-monitoring-led', defaultState: 'collapsed'}
        ];
        
        subLeds.forEach(ledInfo => {
          const led = document.getElementById(ledInfo.id);
          if (led) {
            led.classList.remove('collapsed', 'expanded');
            led.classList.add(ledInfo.defaultState);
          }
        });
      }
      
      // === NAVIGATION DATE ===
      
      // Changer la date du sélecteur
      function changeDate(direction) {
        const dateInput = document.getElementById('drawDate');
        const currentDate = new Date(dateInput.value);
        
        // Vérifier que la date est valide
        if (isNaN(currentDate.getTime())) {
          console.error('Date invalide dans le sélecteur');
          return;
        }
        
        // Ajouter ou soustraire un jour
        currentDate.setDate(currentDate.getDate() + direction);
        
        // Formater la date au format YYYY-MM-DD
        const year = currentDate.getFullYear();
        const month = String(currentDate.getMonth() + 1).padStart(2, '0');
        const day = String(currentDate.getDate()).padStart(2, '0');
        const newDateString = `${year}-${month}-${day}`;
        
        // Mettre à jour le sélecteur
        dateInput.value = newDateString;
        
        console.log(`📅 Date changée: ${direction > 0 ? 'suivant' : 'précédent'} → ${newDateString}`);
      }

      // Fonction pour dessiner le menu cylindrique
      function drawCylMenu() {
        const menuCanvas = document.getElementById('menuCanvas');
        if (!menuCanvas) return;
        
        const header = document.querySelector('.topbar');
        const dpr = window.devicePixelRatio || 1;
        const w = header.clientWidth;
        const h = header.clientHeight;
        menuCanvas.style.position = 'absolute';
        menuCanvas.style.left = '0';
        menuCanvas.style.top = '0';
        menuCanvas.style.width = w + 'px';
        menuCanvas.style.height = h + 'px';
        menuCanvas.width = Math.floor(w * dpr);
        menuCanvas.height = Math.floor(h * dpr);
        const ctx = menuCanvas.getContext('2d');
        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, w, h);

        const radius = Math.min(18, h / 2 - 2);
        const padding = 8;
        const barH = Math.max(h - padding * 2, 12);
        const barW = w - padding * 2;
        const x = padding;
        const y = (h - barH) / 2;

        const grd = ctx.createLinearGradient(0, y, 0, y + barH);
        grd.addColorStop(0, 'rgba(255,255,255,0.18)');
        grd.addColorStop(0.5, 'rgba(255,255,255,0.06)');
        grd.addColorStop(1, 'rgba(0,0,0,0.18)');

        ctx.beginPath();
        roundRect(ctx, x, y, barW, barH, radius);
        ctx.fillStyle = grd;
        ctx.fill();

        // highlight specular
        ctx.beginPath();
        roundRect(ctx, x + 2, y + 2, barW - 4, barH * 0.35, radius * 0.8);
        const hi = ctx.createLinearGradient(0, y + 2, 0, y + 2 + barH * 0.35);
        hi.addColorStop(0, 'rgba(255,255,255,0.25)');
        hi.addColorStop(1, 'rgba(255,255,255,0.02)');
        ctx.fillStyle = hi;
        ctx.fill();

        // shadow bottom
        ctx.beginPath();
        roundRect(ctx, x + 2, y + barH * 0.6, barW - 4, barH * 0.35, radius * 0.8);
        const sh = ctx.createLinearGradient(0, y + barH * 0.6, 0, y + barH);
        sh.addColorStop(0, 'rgba(0,0,0,0.08)');
        sh.addColorStop(1, 'rgba(0,0,0,0.18)');
        ctx.fillStyle = sh;
        ctx.fill();
      }

      function roundRect(ctx, x, y, width, height, radius) {
        const r = Math.max(0, Math.min(radius, height / 2));
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + width - r, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + r);
        ctx.lineTo(x + width, y + height - r);
        ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
        ctx.lineTo(x + r, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
      }

      // Variables globales pour la page Tirage
      let currentDataSource = 'scrap'; // 'mock' ou 'scrap' - Scrap par défaut
      let gainsExpanded = true; // Ouvert par défaut
      let resultsExpanded = true; // Ouvert par défaut

      // Fonctions pour la page Tirage
      function toggleDataSource() {
        const toggle = document.getElementById('dataToggle');
        const switchElement = document.querySelector('.switch');
        
        // Logique inversée : checked = Scrap (à gauche), unchecked = Mock (à droite)
        currentDataSource = toggle.checked ? 'scrap' : 'mock';
        console.log('Source de données changée:', currentDataSource);
        
        // Changer l'apparence visuelle de l'interrupteur selon l'état
        if (toggle.checked) {
          // Mode Scrap actif - style bleu
          switchElement.classList.remove('mock');
          switchElement.classList.add('scrap');
        } else {
          // Mode Mock actif - style gris
          switchElement.classList.remove('scrap');
          switchElement.classList.add('mock');
        }
        
        // Mettre à jour visuellement les labels
        updateSwitchLabels();
        
        // Mettre à jour les LEDs
        updateLeds();
        
        // Mettre à jour le fil d'Ariane
        updateBreadcrumb('source-selected');
      }

      // Fonction pour mettre à jour les LEDs de l'interrupteur
      function updateLeds() {
        const scrapLed = document.getElementById('scrapLed');
        const jsonLed = document.getElementById('jsonLed');
        
        if (currentDataSource === 'scrap') {
          // Mode Scrap actif (interrupteur à GAUCHE) : LED Scrap VERTE, LED Mock GRISE
          if (scrapLed) {
            scrapLed.classList.remove('collapsed');
            scrapLed.classList.add('expanded');
          }
          if (jsonLed) {
            jsonLed.classList.remove('expanded');
            jsonLed.classList.add('collapsed');
          }
        } else {
          // Mode Mock actif (interrupteur à DROITE) : LED Scrap GRISE, LED Mock VERTE
          if (scrapLed) {
            scrapLed.classList.remove('expanded');
            scrapLed.classList.add('collapsed');
          }
          if (jsonLed) {
            jsonLed.classList.remove('collapsed');
            jsonLed.classList.add('expanded');
          }
        }
        
        console.log(`🔄 LEDs mises à jour: Scrap=${currentDataSource === 'scrap' ? 'VERT' : 'GRIS'}, Mock=${currentDataSource === 'mock' ? 'VERT' : 'GRIS'}`);
      }

      // Fonction pour vider le tableau des gains
      function clearGainsTable() {
        const gainsSection = document.getElementById('gainsSection');
        const gainsTableBody = document.getElementById('gainsTableBody');
        
        if (gainsTableBody) {
          gainsTableBody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: rgba(255,255,255,0.5); font-style: italic;">Aucune donnée de gains disponible</td></tr>';
        }
        
        // Masquer la section des gains si elle était visible
        if (gainsSection) {
          gainsSection.style.display = 'none';
        }
      }

      // Fonction pour mettre à jour le fil d'Ariane
      function updateBreadcrumb(step = 'init') {
        const breadcrumb = document.getElementById('dataBreadcrumb');
        const icon = breadcrumb.querySelector('.breadcrumb-icon');
        const text = breadcrumb.querySelector('.breadcrumb-text');
        
        // Réinitialiser les classes
        breadcrumb.className = 'breadcrumb';
        
        switch(step) {
          case 'init':
            icon.textContent = '🔄';
            text.textContent = 'Sélectionnez une date et une source';
            break;
            
          case 'source-selected':
            breadcrumb.classList.add('active');
            icon.textContent = currentDataSource === 'mock' ? '🎲' : '🌐';
            text.textContent = `Source: ${currentDataSource === 'mock' ? 'Mock (données simulées)' : 'Scrap (données réelles)'}`;
            break;
            
          case 'loading-mock':
            breadcrumb.classList.add('active');
            icon.textContent = '🎲';
            text.textContent = 'Mock → Génération de données simulées...';
            break;
            
          case 'loading-scrap':
            breadcrumb.classList.add('active');
            icon.textContent = '🌐';
            text.textContent = 'Scrap → Validation date → Requête réseau → Parsing...';
            break;
            
          case 'success':
            breadcrumb.classList.add('success');
            icon.textContent = '✅';
            if (currentDataSource === 'mock') {
              text.textContent = 'Mock → Données simulées générées avec succès';
            } else {
              text.textContent = 'Scrap → Date validée → Données récupérées → Parsing réussi';
            }
            break;
            
          case 'error':
            breadcrumb.classList.add('error');
            icon.textContent = '❌';
            text.textContent = 'Erreur lors du chargement des données';
            break;
            
          case 'no-draw':
            breadcrumb.classList.add('success');
            icon.textContent = '📅';
            text.textContent = 'Pas de tirage pour cette date (date invalide ou future)';
            break;
        }
      }
      
      function updateSwitchLabels() {
        const toggle = document.getElementById('dataToggle');
        const leftLabel = document.querySelector('.switch-label-left');
        const rightLabel = document.querySelector('.switch-label-right');
        const switchElement = document.querySelector('.switch');
        
        if (toggle.checked) {
          // Mode Scrap actif
          leftLabel.style.opacity = '1';
          leftLabel.style.color = 'var(--accent)';
          rightLabel.style.opacity = '0.6';
          rightLabel.style.color = 'var(--fg)';
          
          // Appliquer les classes actives
          switchElement.classList.remove('mock');
          switchElement.classList.add('scrap');
        } else {
          // Mode Mock actif
          leftLabel.style.opacity = '0.6';
          leftLabel.style.color = 'var(--fg)';
          rightLabel.style.opacity = '1';
          rightLabel.style.color = 'var(--accent)';
          
          // Retirer les classes actives
          switchElement.classList.remove('scrap');
          switchElement.classList.add('mock');
        }
      }
      
      function updateLeds() {
        const toggle = document.getElementById('dataToggle');
        const scrapLed = document.getElementById('scrapLed');
        const jsonLed = document.getElementById('jsonLed');
        
        if (toggle.checked) {
          // Mode Scrap actif
          scrapLed.classList.add('active');
          jsonLed.classList.remove('active');
        } else {
          // Mode Mock actif
          scrapLed.classList.remove('active');
          jsonLed.classList.add('active');
        }
      }

      async function loadDraw() {
        const dateInput = document.getElementById('drawDate');
        const selectedDate = dateInput.value;
        
        if (!selectedDate) {
          alert('Veuillez sélectionner une date');
          return;
        }

        console.log('🎲 Chargement du tirage pour:', selectedDate, 'Source:', currentDataSource);
        
        if (currentDataSource === 'mock') {
          // Mode Mock - affichage direct
          updateBreadcrumb('loading-mock');
          displayDrawResult(selectedDate);
        } else {
          // Mode Scrap - nouvelle stratégie avec vérification base
          await loadDrawWithStrategy(selectedDate);
        }
      }

      // Charger avec force refresh (ignorer la base)
      async function loadDrawForced() {
        console.log('🔄 FORCE REFRESH demandé');
        
        const dateInput = document.getElementById('drawDate');
        const selectedDate = dateInput.value;
        
        if (!selectedDate) {
          alert('Veuillez sélectionner une date');
          return;
        }

        if (currentDataSource === 'mock') {
          alert('Le mode Mock ne nécessite pas de force refresh');
          return;
        }

        console.log('🎯 Force refresh pour:', selectedDate);
        await loadDrawWithStrategy(selectedDate, true); // forceRefresh = true
      }

      // === NOUVELLE STRATÉGIE INTELLIGENTE ===
      
      // Stratégie: 1) Vérifier base SQLite 2) Si vide→message 3) Si absent→scraper+sauver
      async function loadDrawWithStrategy(selectedDate, forceRefresh = false) {
        console.log('🎯 Stratégie intelligente SQLite pour:', selectedDate, forceRefresh ? '(FORCE REFRESH)' : '');
        
        // 1. Regarder si la date existe dans la base SQLite (sauf si force refresh)
        if (!forceRefresh) {
          try {
            const existingDraw = await checkDrawInSQLiteDatabase(selectedDate);
            
            if (existingDraw) {
              console.log('📅 Tirage trouvé en base SQLite:', existingDraw);
              
              // 2a. Si oui et tirage NON vide → afficher
              if (!isEmptyDrawSQLite(existingDraw)) {
                console.log('✅ Tirage valide trouvé en base SQLite, affichage direct');
                updateBreadcrumb('loading-scrap');
                displayDrawFromSQLiteDatabase(existingDraw, selectedDate);
                return;
              }
              
              // 2b. Si oui et tirage VIDE → message "pas de tirage"
              console.log('⭕ Tirage vide trouvé en base SQLite, affichage message');
              displayNoDrawMessage(selectedDate);
              return;
            }
          } catch (error) {
            console.warn('⚠️ Erreur vérification base SQLite:', error.message);
            // Continuer avec le scraping en cas d'erreur de base
          }
        }
        
        // 3. Si non (ou force refresh) → scraper, afficher et mettre en base SQLite
        console.log('🌐 Aucune donnée valide en base SQLite, scraping nécessaire');
        updateBreadcrumb('loading-scrap');
        await scrapSaveAndDisplay(selectedDate);
      }
      
      // ========================================
      // Fonctions SQLite pour scraping
      // ========================================
      
      // Vérifier si un tirage existe dans la base SQLite
      async function checkDrawInSQLiteDatabase(selectedDate) {
        console.log('🔍 Vérification tirage SQLite pour date:', selectedDate);
        
        try {
          // Utiliser l'API SQLite backend pour récupérer les tirages
          const response = await fetch(`http://localhost:3001/api/tables/tirages`, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json'
            }
          });

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const result = await response.json();
          
          if (result.success && result.data) {
            // Chercher un tirage avec la date correspondante
            const existingDraw = result.data.find(tirage => tirage.date === selectedDate);
            
            if (existingDraw) {
              console.log('✅ Tirage trouvé dans SQLite:', existingDraw);
              return existingDraw;
            }
          }
          
          console.log('ℹ️ Aucun tirage trouvé pour cette date dans SQLite');
          return null;
          
        } catch (error) {
          console.error('❌ Erreur vérification SQLite:', error);
          throw error;
        }
      }
      
      // Vérifier si un tirage SQLite est vide (que des 0)
      function isEmptyDrawSQLite(drawData) {
        if (!drawData.numeros || !drawData.etoiles) {
          console.log('🔍 Tirage SQLite invalide: pas de numeros/etoiles');
          return true;
        }
        
        // Convertir les chaînes en tableaux si nécessaire
        let numbers = drawData.numeros;
        let stars = drawData.etoiles;
        
        if (typeof numbers === 'string') {
          numbers = numbers.split(',').map(n => parseInt(n.trim()));
        }
        if (typeof stars === 'string') {
          stars = stars.split(',').map(s => parseInt(s.trim()));
        }
        
        // Vérifier si tous les numéros sont 0
        const allNumbersZero = numbers.every(num => num === 0);
        const allStarsZero = stars.every(star => star === 0);
        
        const isEmpty = allNumbersZero && allStarsZero;
        console.log('🔍 Vérification tirage SQLite vide:', {
          numeros: numbers,
          etoiles: stars,
          isEmpty: isEmpty
        });
        
        return isEmpty;
      }
      
      // Afficher un tirage depuis la base SQLite
      function displayDrawFromSQLiteDatabase(drawData, selectedDate) {
        console.log('🎨 Affichage tirage depuis base SQLite:', drawData);
        
        // Convertir les données SQLite au format attendu par l'affichage
        let numbers = drawData.numeros;
        let stars = drawData.etoiles;
        
        if (typeof numbers === 'string') {
          numbers = numbers.split(',').map(n => parseInt(n.trim()));
        }
        if (typeof stars === 'string') {
          stars = stars.split(',').map(s => parseInt(s.trim()));
        }
        
        // Formatter la date
        const dateObj = new Date(selectedDate + 'T00:00:00');
        const formattedDate = dateObj.toLocaleDateString('fr-FR', {
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
        
        // Afficher les résultats
        const resultsSection = document.getElementById('resultsSection');
        const resultDate = document.getElementById('resultDate');
        const resultBalls = document.getElementById('resultBalls');
        
        resultDate.textContent = formattedDate.charAt(0).toUpperCase() + formattedDate.slice(1);
        
        // Créer les boules
        resultBalls.innerHTML = '';
        
        // Boules numéros
        numbers.forEach(number => {
          const ball = document.createElement('span');
          ball.className = 'ball';
          ball.textContent = number;
          resultBalls.appendChild(ball);
        });
        
        // Boules étoiles
        stars.forEach(star => {
          const starBall = document.createElement('span');
          starBall.className = 'ball star';
          starBall.textContent = star;
          resultBalls.appendChild(starBall);
        });
        
        resultsSection.style.display = 'block';
        updateBreadcrumb('success');
        
        console.log('✅ Tirage SQLite affiché avec succès');
      }

      // Vérifier si un tirage est vide (que des 0) - Version legacy
      function isEmptyDraw(drawData) {
        if (!drawData.numbers || !drawData.stars) {
          console.log('🔍 Tirage invalide: pas de numbers/stars');
          return true;
        }
        
        // Vérifier si tous les numéros sont 0
        const allNumbersZero = drawData.numbers.every(num => num === 0);
        const allStarsZero = drawData.stars.every(star => star === 0);
        
        const isEmpty = allNumbersZero && allStarsZero;
        console.log('🔍 Vérification tirage vide:', {
          numbers: drawData.numbers,
          stars: drawData.stars,
          isEmpty: isEmpty
        });
        
        return isEmpty;
      }
      
      // Afficher un tirage depuis la base de données
      function displayDrawFromDatabase(drawData, selectedDate) {
        console.log('📊 Affichage depuis base:', drawData);
        
        const resultsSection = document.getElementById('resultsSection');
        const resultDate = document.getElementById('resultDate');
        const resultBalls = document.getElementById('resultBalls');
        
        // Formatter la date
        const dateObj = new Date(selectedDate + 'T00:00:00');
        const formattedDate = dateObj.toLocaleDateString('fr-FR', {
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
        
        resultDate.textContent = formattedDate.charAt(0).toUpperCase() + formattedDate.slice(1);
        
        // Créer les boules
        resultBalls.innerHTML = '';
        
        // Boules numéros
        drawData.numbers.forEach((number, index) => {
          const ball = document.createElement('span');
          ball.className = 'ball';
          ball.textContent = number;
          resultBalls.appendChild(ball);
        });
        
        // Boules étoiles
        drawData.stars.forEach((star, index) => {
          const starBall = document.createElement('span');
          starBall.className = 'ball star';
          starBall.textContent = star;
          resultBalls.appendChild(starBall);
        });
        
        resultsSection.style.display = 'block';
        
        // Afficher les gains si disponibles
        if (drawData.gains && drawData.gains.length > 0) {
          displayGainsFromData(drawData);
        }
        
        updateBreadcrumb('success');
        console.log('✅ Affichage base terminé');
      }
      
      // Afficher le message "pas de tirage trouvé"
      function displayNoDrawMessage(selectedDate) {
        console.log('ℹ️ Affichage message pas de tirage pour:', selectedDate);
        
        const resultsSection = document.getElementById('resultsSection');
        const resultDate = document.getElementById('resultDate');
        const resultBalls = document.getElementById('resultBalls');
        
        // Formatter la date
        const dateObj = new Date(selectedDate + 'T00:00:00');
        const formattedDate = dateObj.toLocaleDateString('fr-FR', {
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
        
        resultDate.textContent = formattedDate.charAt(0).toUpperCase() + formattedDate.slice(1);
        
        // Message informatif
        resultBalls.innerHTML = `
          <div style="text-align: center; padding: 30px; color: var(--accent);">
            <div style="font-size: 48px; margin-bottom: 15px;">📅</div>
            <div style="font-size: 18px; font-weight: 600; margin-bottom: 10px;">Pas de tirage trouvé</div>
            <div style="font-size: 14px; color: #888;">Aucun tirage EuroMillions pour cette date</div>
          </div>
        `;
        
        resultsSection.style.display = 'block';
        updateBreadcrumb('info');
        console.log('ℹ️ Message pas de tirage affiché');
      }
      
      // Scraper, sauvegarder et afficher
      async function scrapSaveAndDisplay(selectedDate) {
        console.log('🌐 Début scraping + sauvegarde pour:', selectedDate);
        
        try {
          // Utiliser la fonction de scraping existante
          const scrapedData = await scrapDrawFromLotteryExtreme(selectedDate);
          
          if (scrapedData && scrapedData.numbers && scrapedData.stars) {
            console.log('✅ Scraping réussi, données reçues:', scrapedData);
            console.log('🎯 Structure des données scrappées:', {
              numbers: scrapedData.numbers,
              stars: scrapedData.stars,
              breakdown: scrapedData.breakdown,
              gains: scrapedData.gains,
              breakdownLength: scrapedData.breakdown ? scrapedData.breakdown.length : 'undefined'
            });
            
            // Mapper breakdown vers gains avec format unifié
            const gains = (scrapedData.breakdown || []).map(item => ({
              rang: item.rankLabel,
              gagnants: item.winners,
              gain: item.amount,
              // Garder aussi les propriétés originales pour compatibilité
              rankLabel: item.rankLabel,
              winners: item.winners,
              amount: item.amount
            }));
            
            console.log('🎯 Gains mappés pour sauvegarde:', gains);
            
            // Sauvegarder en base
            const dataToSave = {
              date: selectedDate,
              numbers: scrapedData.numbers,
              stars: scrapedData.stars,
              gains: gains,
              source: 'scraped',
              timestamp: new Date().toISOString()
            };
            
            localStorage.setItem(`draw_${selectedDate}`, JSON.stringify(dataToSave));
            console.log('💾 Données sauvegardées en base');
            
            // Vérification immédiate de la sauvegarde
            const savedData = JSON.parse(localStorage.getItem(`draw_${selectedDate}`));
            console.log('✅ Vérification sauvegarde - données récupérées:', savedData);
            console.log('🎯 Vérification gains après sauvegarde:', savedData.gains);
            console.log('📊 Nombre de gains sauvegardés:', savedData.gains ? savedData.gains.length : 'undefined');
            
            // Afficher les résultats (utiliser les fonctions existantes)
            console.log('🎨 Affichage des résultats...');
            
            // Afficher les boules du tirage
            const resultsSection = document.getElementById('resultsSection');
            const resultDate = document.getElementById('resultDate');
            const resultBalls = document.getElementById('resultBalls');
            
            // Formatter la date
            const dateObj = new Date(selectedDate + 'T00:00:00');
            const formattedDate = dateObj.toLocaleDateString('fr-FR', {
              weekday: 'long',
              year: 'numeric',
              month: 'long',
              day: 'numeric'
            });
            
            resultDate.textContent = formattedDate.charAt(0).toUpperCase() + formattedDate.slice(1);
            
            // Créer les boules
            resultBalls.innerHTML = '';
            
            // Boules numéros
            scrapedData.numbers.forEach(number => {
              const ball = document.createElement('span');
              ball.className = 'ball';
              ball.textContent = number;
              resultBalls.appendChild(ball);
            });
            
            // Boules étoiles
            scrapedData.stars.forEach(star => {
              const starBall = document.createElement('span');
              starBall.className = 'ball star';
              starBall.textContent = star;
              resultBalls.appendChild(starBall);
            });
            
            resultsSection.style.display = 'block';
            
            // Afficher les gains avec les données mappées
            if (scrapedData.breakdown && scrapedData.breakdown.length > 0) {
              console.log('🎯 Affichage des gains avec breakdown:', scrapedData.breakdown);
              
              // Créer un objet compatible avec displayGainsData
              const mockDataForDisplay = {
                gains: gains // Utiliser les gains déjà mappés
              };
              
              console.log('🎯 Données gains formatées pour affichage:', mockDataForDisplay);
              displayGainsData(mockDataForDisplay);
            } else {
              console.log('⚠️ Pas de breakdown, affichage gains par défaut');
              displayGainsData();
            }
            
            updateBreadcrumb('success');
            
          } else {
            console.log('⭕ Scraping retourné vide, sauvegarde tirage vide');
            
            // Sauvegarder un tirage vide
            const emptyDraw = {
              date: selectedDate,
              numbers: [0, 0, 0, 0, 0],
              stars: [0, 0],
              gains: [],
              source: 'scraped_empty',
              timestamp: new Date().toISOString()
            };
            
            localStorage.setItem(`draw_${selectedDate}`, JSON.stringify(emptyDraw));
            console.log('💾 Tirage vide sauvegardé');
            
            // Afficher le message de tirage vide
            const resultsSection = document.getElementById('resultsSection');
            const resultDate = document.getElementById('resultDate');
            const resultBalls = document.getElementById('resultBalls');
            
            // Formatter la date
            const dateObj = new Date(selectedDate + 'T00:00:00');
            const formattedDate = dateObj.toLocaleDateString('fr-FR', {
              weekday: 'long',
              year: 'numeric',
              month: 'long',
              day: 'numeric'
            });
            
            resultDate.textContent = formattedDate.charAt(0).toUpperCase() + formattedDate.slice(1);
            
            resultBalls.innerHTML = `
              <div style="text-align: center; padding: 30px; color: var(--accent);">
                <div style="font-size: 48px; margin-bottom: 15px;">📅</div>
                <div style="font-size: 18px; font-weight: 600; margin-bottom: 10px;">Pas de tirage trouvé</div>
                <div style="font-size: 14px; color: #888;">Aucun tirage EuroMillions pour cette date</div>
              </div>
            `;
            
            resultsSection.style.display = 'block';
            updateBreadcrumb('info');
          }
          
        } catch (error) {
          console.error('❌ Erreur de scraping (ne sauvegarde pas):', error);
          
          // NE PAS sauvegarder en cas d'erreur technique
          // Utiliser la gestion d'erreur existante
          const resultsSection = document.getElementById('resultsSection');
          const resultDate = document.getElementById('resultDate');
          const resultBalls = document.getElementById('resultBalls');
          
          // Formatter la date
          const dateObj = new Date(selectedDate + 'T00:00:00');
          const formattedDate = dateObj.toLocaleDateString('fr-FR', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric'
          });
          
          resultDate.textContent = formattedDate.charAt(0).toUpperCase() + formattedDate.slice(1);
          
          // Affichage différentié selon le type d'erreur (reprendre la logique existante)
          let messageIcon, messageTitle, messageContent, messageAdvice, isNoDraw = false;
          
          if (error.message.startsWith('NO_DRAW_FOR_DATE') || error.message.startsWith('NOT_DRAW_DAY')) {
            isNoDraw = true;
            messageIcon = '📅';
            messageTitle = 'Aucun tirage trouvé';
            messageContent = `Pas de tirage EuroMillions disponible pour le ${selectedDate}`;
            messageAdvice = '💡 Les tirages EuroMillions ont lieu les mardis et vendredis soir';
          } else if (error.message.startsWith('FUTURE_DATE')) {
            messageIcon = '🔮';
            messageTitle = 'Date future';
            messageContent = `Le tirage du ${selectedDate} n'a pas encore eu lieu`;
            messageAdvice = '💡 Sélectionnez une date passée pour voir les résultats';
          } else {
            messageIcon = '⚠️';
            messageTitle = 'Erreur technique';
            messageContent = 'Impossible de récupérer les données pour le moment';
            messageAdvice = '💡 Vérifiez votre connexion internet et réessayez';
          }
          
          const messageClass = isNoDraw ? 'info-message' : 'error-message';
          
          resultBalls.innerHTML = `
            <div class="${messageClass}" style="padding: 20px; border-radius: 8px; text-align: center; margin: 20px 0;">
              <div style="font-size: 32px; margin-bottom: 10px;">${messageIcon}</div>
              <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">${messageTitle}</div>
              <div style="font-size: 14px; margin-bottom: 12px;">${messageContent}</div>
              <div style="font-size: 12px; font-style: italic;">${messageAdvice}</div>
            </div>
          `;
          
          resultsSection.style.display = 'block';
          updateBreadcrumb(isNoDraw ? 'info' : 'error');
        }
      }

      function displayDrawResult(date) {
        const resultsSection = document.getElementById('resultsSection');
        const resultDate = document.getElementById('resultDate');
        const resultBalls = document.getElementById('resultBalls');

        // Formatter la date
        const dateObj = new Date(date + 'T00:00:00');
        const formattedDate = dateObj.toLocaleDateString('fr-FR', {
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });

        resultDate.textContent = formattedDate.charAt(0).toUpperCase() + formattedDate.slice(1);

        // Utiliser les vraies données Mock
        const drawDate = dateObj.toLocaleDateString('fr-FR');
        let drawData = window.mockEuroMillion.getDrawByDate(drawDate);
        
        if (!drawData) {
          console.log('📅 Génération nouveau tirage mock pour:', drawDate);
          drawData = window.mockEuroMillion.generateSingleDraw(dateObj);
        }
        
        const numbers = drawData.numbers;
        const stars = drawData.stars;
        console.log('🎲 Données Mock chargées:', numbers, 'étoiles:', stars);

        // Créer les boules
        resultBalls.innerHTML = '';
        
        // Boules principales
        numbers.forEach(num => {
          const ball = document.createElement('div');
          ball.className = 'ball';
          ball.textContent = num;
          resultBalls.appendChild(ball);
        });

        // Étoiles
        stars.forEach(star => {
          const ball = document.createElement('div');
          ball.className = 'ball star';
          ball.textContent = star;
          resultBalls.appendChild(ball);
        });

        resultsSection.style.display = 'block';
        
        // Afficher les gains Mock
        console.log('🎯 Appel displayGainsData avec drawData:', drawData);
        displayGainsData(drawData);
        
        // Mettre à jour le fil d'Ariane
        updateBreadcrumb('success');
      }

      // Fonction de scraping réel
      async function performRealScraping(date) {
        const resultsSection = document.getElementById('resultsSection');
        const resultDate = document.getElementById('resultDate');
        const resultBalls = document.getElementById('resultBalls');
        
        try {
          // Formatter la date pour l'affichage
          const dateObj = new Date(date + 'T00:00:00');
          const formattedDate = dateObj.toLocaleDateString('fr-FR', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric'
          });
          
          resultDate.textContent = formattedDate.charAt(0).toUpperCase() + formattedDate.slice(1);
          
          // Afficher un indicateur de chargement
          resultBalls.innerHTML = '<div class="loading">🔄 Scraping en cours...</div>';
          resultsSection.style.display = 'block';
          
          // Convertir la date au format YYYY-MM-DD pour le scraping
          const scrapDate = date;
          console.log('🌐 Scraping pour la date:', scrapDate);
          
          // Appeler le service de scraping (proto)
          const scrapedData = await scrapDrawFromLotteryExtreme(scrapDate);
          
          if (scrapedData && scrapedData.numbers && scrapedData.stars) {
            console.log('✅ Scraping réussi:', scrapedData);
            
            // Mettre à jour le fil d'Ariane
            updateBreadcrumb('success');
            
            // Afficher les boules scrapées
            resultBalls.innerHTML = '';
            
            // Boules principales
            scrapedData.numbers.forEach(num => {
              const ball = document.createElement('div');
              ball.className = 'ball';
              ball.textContent = num;
              resultBalls.appendChild(ball);
            });
            
            // Étoiles
            scrapedData.stars.forEach(star => {
              const ball = document.createElement('div');
              ball.className = 'ball star';
              ball.textContent = star;
              resultBalls.appendChild(ball);
            });
            
            // Afficher les gains scrapés si disponibles
            if (scrapedData.breakdown) {
              displayScrapedGains(scrapedData.breakdown);
            } else {
              displayGainsData(); // Gains par défaut
            }
            
          } else {
            throw new Error('Aucune donnée trouvée pour cette date');
          }
          
        } catch (error) {
          console.error('❌ Erreur de scraping:', error);
          
          // Affichage différentié selon le type d'erreur
          let messageIcon, messageTitle, messageContent, messageAdvice, isNoDraw = false;
          
          if (error.message.startsWith('NO_DRAW_FOR_DATE')) {
            isNoDraw = true;
            messageIcon = '📅';
            messageTitle = 'Aucun tirage trouvé';
            messageContent = `Pas de tirage EuroMillions disponible pour le ${date}`;
            messageAdvice = '💡 Les tirages EuroMillions ont lieu les mardis et vendredis soir';
          } else if (error.message.startsWith('NOT_DRAW_DAY')) {
            isNoDraw = true;
            const dateObj = new Date(date);
            const dayName = dateObj.toLocaleDateString('fr-FR', { weekday: 'long' });
            messageIcon = '📆';
            messageTitle = 'Jour incorrect';
            messageContent = `${dayName} n'est pas un jour de tirage EuroMillions`;
            messageAdvice = '💡 Les tirages ont lieu uniquement les mardis et vendredis';
          } else if (error.message.startsWith('FUTURE_DATE')) {
            messageIcon = '🔮';
            messageTitle = 'Date future';
            messageContent = `Le tirage du ${date} n'a pas encore eu lieu`;
            messageAdvice = '💡 Sélectionnez une date passée pour voir les résultats';
          } else if (error.message.startsWith('PARSE_ERROR')) {
            messageIcon = '🔍';
            messageTitle = 'Erreur de parsing';
            messageContent = 'Données incomplètes trouvées sur le site';
            messageAdvice = '💡 Le format de la page a peut-être changé, réessayez plus tard';
          } else if (error.message.startsWith('TECHNICAL_ERROR')) {
            messageIcon = '⚠️';
            messageTitle = 'Erreur technique';
            messageContent = 'Problème de connexion ou de site web';
            messageAdvice = '💡 Vérifiez votre connexion Internet et réessayez';
          } else {
            messageIcon = '❌';
            messageTitle = 'Erreur inconnue';
            messageContent = error.message;
            messageAdvice = '💡 Veuillez réessayer ou contactez le support';
          }
          
          // Choisir la classe CSS selon le type (vert pour "pas de tirage", rouge pour erreurs)
          const messageClass = isNoDraw ? 'no-draw' : 'error';
          const detailsClass = isNoDraw ? 'no-draw-details' : 'error-details';
          
          // Mettre à jour le fil d'Ariane
          updateBreadcrumb(isNoDraw ? 'no-draw' : 'error');
          
          // Vider le tableau des gains en cas d'erreur
          clearGainsTable();
          
          // Affichage immédiat d'un message court
          resultBalls.innerHTML = `<div class="${messageClass}">${messageIcon} ${messageTitle}</div>`;
          
          // Affichage détaillé après un délai
          setTimeout(() => {
            resultBalls.innerHTML = `
              <div class="${detailsClass}">
                <p>${messageIcon} <strong>${messageTitle}</strong></p>
                <p><strong>Date:</strong> ${date}</p>
                <p><strong>Détail:</strong> ${messageContent}</p>
                <p>${messageAdvice}</p>
                ${isNoDraw ? 
                  '<p><strong>💡 Suggestion:</strong> Essayez avec une date de mardi ou vendredi récente</p>' : ''}
              </div>
            `;
          }, 1000);
        }
      }

      // Fonction de scraping améliorée avec détection intelligente d'erreurs
      async function scrapDrawFromLotteryExtreme(dateString) {
        try {
          // VALIDATION PRÉLIMINAIRE (avant requête réseau)
          const dateObj = new Date(dateString);
          const today = new Date();
          
          // Vérifier si c'est un jour de tirage (mardi=2, vendredi=5)
          const dayOfWeek = dateObj.getDay();
          if (dayOfWeek !== 2 && dayOfWeek !== 5) {
            console.log('⚡ Détection rapide: Pas un jour de tirage ->', dateString, 'jour:', dayOfWeek);
            throw new Error('NOT_DRAW_DAY');
          }
          
          // Vérifier si c'est une date future (plus de 1 jour dans le futur pour éviter les problèmes de timezone)
          const tomorrow = new Date(today);
          tomorrow.setDate(today.getDate() + 1);
          if (dateObj > tomorrow) {
            console.log('⚡ Détection rapide: Date future ->', dateString);
            throw new Error('FUTURE_DATE');
          }
          
          console.log('✅ Date valide pour scraping ->', dateString, 'jour:', dayOfWeek);
          
          // Maintenant faire la requête réseau
          const url = `https://api.allorigins.win/get?url=${encodeURIComponent(`https://www.lotteryextreme.com/euromillions/prize_breakdown(${dateString})`)}`;
          
          console.log('🌐 URL de scraping:', url);
          
          const response = await fetch(url);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`, { cause: 'NETWORK_ERROR' });
          }
          
          const data = await response.json();
          const html = data.contents;
          
          // Vérifier si la page indique explicitement "pas de tirage"
          if (html.includes('No data available') || 
              html.includes('Draw not found') ||
              html.includes('not yet available') ||
              html.includes('Coming Soon') ||
              html.toLowerCase().includes('no results')) {
            throw new Error('NO_DRAW_FOR_DATE');
          }
          
          // Parser le HTML avec une approche simplifiée
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');
          
          // Vérifier si on est sur une page d'erreur 404 ou similaire
          const pageTitle = doc.querySelector('title')?.textContent || '';
          if (pageTitle.toLowerCase().includes('404') || 
              pageTitle.toLowerCase().includes('not found') ||
              pageTitle.toLowerCase().includes('error')) {
            throw new Error('NO_DRAW_FOR_DATE');
          }
          
          // Extraire les numéros depuis les éléments .displayball
          const ballElements = doc.querySelectorAll('ul.displayball li');
          const numbers = [];
          
          ballElements.forEach(el => {
            const num = parseInt(el.textContent.trim(), 10);
            if (!isNaN(num)) {
              numbers.push(num);
            }
          });
          
          // Si aucun numéro trouvé après scraping d'une date valide
          if (numbers.length === 0) {
            throw new Error('NO_DRAW_FOR_DATE');
          }
          
          if (numbers.length < 7) {
            throw new Error(`PARSE_ERROR: expected 7 numbers, got ${numbers.length}`);
          }
          
          const mainNumbers = numbers.slice(0, 5);
          const stars = numbers.slice(5, 7);
          
          // Extraire le tableau des gains
          const breakdown = [];
          const gainRows = doc.querySelectorAll('table.tbsg tr.sg1, table.tbsg tr.sg2');
          
          gainRows.forEach(row => {
            const cells = row.querySelectorAll('td');
            if (cells.length >= 3) {
              const rank = cells[0].textContent.replace(/\s+/g, '');
              const winners = parseInt(cells[1].textContent.replace(/[^0-9]/g, ''), 10) || 0;
              const amount = cells[2].textContent.trim();
              
              if (/^\d+\+\d+$/.test(rank)) {
                breakdown.push({
                  rankLabel: rank,
                  winners: winners,
                  amount: amount,
                  currency: 'EUR'
                });
              }
            }
          });
          
          return {
            date: dateString,
            numbers: mainNumbers,
            stars: stars,
            breakdown: breakdown,
            meta: {
              provider: 'lotteryextreme',
              scrapedAt: new Date().toISOString()
            }
          };
          
        } catch (error) {
          console.error('Erreur de scraping:', error);
          
          // Re-lancer l'erreur avec le message original si c'est une erreur spécifique
          if (error.message.startsWith('NO_DRAW_FOR_DATE') || 
              error.message.startsWith('FUTURE_DATE') || 
              error.message.startsWith('NOT_DRAW_DAY') ||
              error.message.startsWith('PARSE_ERROR')) {
            throw error;
          }
          
          // Pour les autres erreurs, les marquer comme erreurs techniques
          throw new Error(`TECHNICAL_ERROR: ${error.message}`);
        }
      }

      // Fonction pour afficher les gains scrapés
      function displayScrapedGains(breakdown) {
        const gainsSection = document.getElementById('gainsSection');
        const gainsTableBody = document.getElementById('gainsTableBody');
        
        if (!breakdown || breakdown.length === 0) {
          gainsTableBody.innerHTML = '<tr><td colspan="4">Aucune donnée de gains disponible</td></tr>';
          gainsSection.style.display = 'block';
          return;
        }
        
        gainsTableBody.innerHTML = '';
        
        breakdown.forEach((gain, index) => {
          const row = document.createElement('tr');
          
          // Créer la cellule de combinaison avec icônes
          const comboCell = document.createElement('td');
          const comboDiv = document.createElement('div');
          comboDiv.className = 'result-combo';
          
          // Mapper les rangs aux combinaisons EuroMillions
          const combos = ['5+2', '5+1', '5+0', '4+2', '4+1', '3+2', '4+0', '2+2', '3+1', '3+0', '1+2', '2+1', '2+0'];
          const comboText = combos[index] || gain.rankLabel;
          
          if (comboText.includes('+')) {
            const [balls, starsCount] = comboText.split('+');
            
            // Ajouter la boule avec le chiffre (utilise les vraies classes de boules)
            const ballIcon = document.createElement('span');
            ballIcon.className = 'ball';
            ballIcon.style.width = '28px';
            ballIcon.style.height = '28px';
            ballIcon.style.fontSize = '14px';
            ballIcon.textContent = balls;
            comboDiv.appendChild(ballIcon);
            
            // Ajouter le signe +
            if (parseInt(starsCount) > 0) {
              const plus = document.createElement('span');
              plus.textContent = ' + ';
              plus.style.margin = '0 4px';
              comboDiv.appendChild(plus);
              
              // Ajouter l'étoile avec le chiffre (utilise les vraies classes d'étoiles)
              const starIcon = document.createElement('span');
              starIcon.className = 'ball star';
              starIcon.style.width = '28px';
              starIcon.style.height = '28px';
              starIcon.style.fontSize = '12px';
              starIcon.textContent = starsCount;
              comboDiv.appendChild(starIcon);
            }
          } else {
            comboDiv.textContent = gain.rankLabel;
          }
          
          comboCell.appendChild(comboDiv);
          
          // Créer la cellule de gain
          const gainCell = document.createElement('td');
          const gainSpan = document.createElement('span');
          gainSpan.className = 'gain-amount';
          gainSpan.textContent = gain.amount;
          gainCell.appendChild(gainSpan);
          
          row.innerHTML = `
            <td>Rang ${index + 1}</td>
            <td></td>
            <td>${gain.winners.toLocaleString('fr-FR')}</td>
            <td></td>
          `;
          
          // Remplacer les cellules vides par nos éléments
          row.cells[1].replaceWith(comboCell);
          row.cells[3].replaceWith(gainCell);
          
          gainsTableBody.appendChild(row);
        });
        
        gainsSection.style.display = 'block';
        console.log('✅ Gains scrapés affichés:', breakdown.length, 'rangs');
      }

      function displayGainsData(mockDrawData = null) {
        console.log('🎯 displayGainsData appelée avec:', mockDrawData);
        console.log('🎯 currentDataSource:', currentDataSource);
        
        const gainsSection = document.getElementById('gainsSection');
        const gainsTableBody = document.getElementById('gainsTableBody');
        
        console.log('🎯 gainsSection trouvé:', !!gainsSection);
        console.log('🎯 gainsTableBody trouvé:', !!gainsTableBody);

        let gainsData;
        
        if (mockDrawData && mockDrawData.gains && mockDrawData.gains.length > 0) {
          // Utiliser les données fournies (Mock ou Scraped)
          gainsData = mockDrawData.gains.map((gain, index) => ({
            rank: index + 1,
            combo: gain.rang || gain.rankLabel || `${index + 1}+0`,
            winners: gain.gagnants || gain.winners || 0,
            gain: gain.gain || gain.amount || 'N/A'
          }));
          console.log('🎲 Gains fournis chargés:', gainsData.length, 'rangs, source:', currentDataSource);
        } else {
          // Données de gains par défaut (Scrap simulé)
          gainsData = [
            { rank: 1, combo: '5+2', winners: 0, gain: '220 000 000 €' },
            { rank: 2, combo: '5+1', winners: 3, gain: '852 214 €' },
            { rank: 3, combo: '5+0', winners: 8, gain: '45 628 €' },
            { rank: 4, combo: '4+2', winners: 47, gain: '4 086 €' },
            { rank: 5, combo: '4+1', winners: 892, gain: '215 €' },
            { rank: 6, combo: '3+2', winners: 1653, gain: '118 €' },
            { rank: 7, combo: '4+0', winners: 2107, gain: '91 €' },
            { rank: 8, combo: '2+2', winners: 25847, gain: '25 €' },
            { rank: 9, combo: '3+1', winners: 38526, gain: '18 €' },
            { rank: 10, combo: '3+0', winners: 91204, gain: '15 €' },
            { rank: 11, combo: '1+2', winners: 147852, gain: '8 €' },
            { rank: 12, combo: '2+1', winners: 698471, gain: '6 €' },
            { rank: 13, combo: '2+0', winners: 1654820, gain: '4 €' }
          ];
          console.log('🌐 Gains Scrap simulés chargés');
        }

        // Vider le tableau
        gainsTableBody.innerHTML = '';

        // Remplir le tableau
        gainsData.forEach(data => {
          const row = document.createElement('tr');
          
          // Créer la combinaison avec icônes
          const comboCell = document.createElement('td');
          const comboDiv = document.createElement('div');
          comboDiv.className = 'result-combo';
          
          const [balls, starsCount] = data.combo.split('+');
          
          // Ajouter la boule avec le chiffre (utilise les vraies classes de boules)
          const ballIcon = document.createElement('span');
          ballIcon.className = 'ball';
          ballIcon.style.width = '28px';
          ballIcon.style.height = '28px';
          ballIcon.style.fontSize = '14px';
          ballIcon.textContent = balls;
          comboDiv.appendChild(ballIcon);
          
          // Ajouter le signe +
          if (parseInt(starsCount) > 0) {
            const plus = document.createElement('span');
            plus.textContent = ' + ';
            plus.style.margin = '0 4px';
            comboDiv.appendChild(plus);
            
            // Ajouter l'étoile avec le chiffre (utilise les vraies classes d'étoiles)
            const starIcon = document.createElement('span');
            starIcon.className = 'ball star';
            starIcon.style.width = '28px';
            starIcon.style.height = '28px';
            starIcon.style.fontSize = '12px';
            starIcon.textContent = starsCount;
            comboDiv.appendChild(starIcon);
          }
          
          comboCell.appendChild(comboDiv);

          // Formater le gain
          const gainCell = document.createElement('td');
          const gainSpan = document.createElement('span');
          gainSpan.className = 'gain-amount';
          gainSpan.textContent = data.gain;
          gainCell.appendChild(gainSpan);

          row.innerHTML = `
            <td>${data.rank}</td>
            <td></td>
            <td>${data.winners.toLocaleString('fr-FR')}</td>
            <td></td>
          `;
          
          // Remplacer les cellules vides par nos éléments
          row.cells[1].replaceWith(comboCell);
          row.cells[3].replaceWith(gainCell);

          gainsTableBody.appendChild(row);
        });

        gainsSection.style.display = 'block';
        console.log('✅ gainsSection affiché, nombre de lignes ajoutées:', gainsData.length);
      }

      function toggleResults() {
        const resultsContent = document.getElementById('resultsContent');
        const resultsToggle = document.getElementById('resultsToggle');
        const resultsLed = document.getElementById('results-led');
        
        const isExpanded = resultsContent.classList.contains('expanded');
        
        if (isExpanded) {
          resultsContent.classList.remove('expanded');
          resultsToggle.classList.remove('expanded');
          if (resultsLed) {
            resultsLed.classList.remove('expanded');
            resultsLed.classList.add('collapsed');
          }
        } else {
          resultsContent.classList.add('expanded');
          resultsToggle.classList.add('expanded');
          if (resultsLed) {
            resultsLed.classList.remove('collapsed');
            resultsLed.classList.add('expanded');
          }
        }
      }

      function toggleGains() {
        const gainsContent = document.getElementById('gainsContent');
        const gainsToggle = document.getElementById('gainsToggle');
        const gainsLed = document.getElementById('gains-led');
        
        const isExpanded = gainsContent.classList.contains('expanded');
        
        if (isExpanded) {
          gainsContent.classList.remove('expanded');
          gainsToggle.classList.remove('expanded');
          if (gainsLed) {
            gainsLed.classList.remove('expanded');
            gainsLed.classList.add('collapsed');
          }
        } else {
          gainsContent.classList.add('expanded');
          gainsToggle.classList.add('expanded');
          if (gainsLed) {
            gainsLed.classList.remove('collapsed');
            gainsLed.classList.add('expanded');
          }
        }
      }

      // Afficher la section d'accueil par défaut
      document.addEventListener('DOMContentLoaded', () => {
        console.log('🚀 FDJ Architecture OOP - Index unifié chargé');
          
          // DEBUG LED - Vérification détaillée
          console.log('🔍 DEBUG LED - Vérification de l\'affichage:');
          
          // 1. Vérifier si le CSS est chargé
          const ledCssLink = document.querySelector('link[href*="led-components.css"]');
          console.log('📄 LED CSS Link trouvé:', ledCssLink ? 'OUI' : 'NON');
          if (ledCssLink) {
            console.log('🔗 Chemin LED CSS:', ledCssLink.href);
            console.log('📊 État du lien:', ledCssLink.sheet ? 'CHARGÉ' : 'NON CHARGÉ');
          }
          
          // 2. Vérifier si l'élément LED existe
          const homeLed = document.querySelector('.home-led');
          console.log('💡 Élément .home-led trouvé:', homeLed ? 'OUI' : 'NON');
          if (homeLed) {
            console.log('📐 Styles calculés LED:', window.getComputedStyle(homeLed));
            console.log('🎨 Background LED:', window.getComputedStyle(homeLed).background);
            console.log('📏 Dimensions LED:', {
              width: window.getComputedStyle(homeLed).width,
              height: window.getComputedStyle(homeLed).height,
              display: window.getComputedStyle(homeLed).display
            });
          }
          
          // 3. Lister tous les styles chargés
          console.log('📋 Nombre de feuilles de style:', document.styleSheets.length);
          for (let i = 0; i < document.styleSheets.length; i++) {
            const sheet = document.styleSheets[i];
            console.log(`📄 Feuille ${i}:`, sheet.href || 'INLINE');
          }
          
          // Afficher la section home SEULEMENT au premier chargement
          // Si aucune section n'est visible, montrer home par défaut
          const visibleSections = document.querySelectorAll('.section:not(.hidden)');
          if (visibleSections.length === 0) {
        showSection('admin-monitoring');
          }
        
        // Dessiner le menu cylindrique
        drawCylMenu();
        
        // Redessiner le menu lors du redimensionnement
        window.addEventListener('resize', drawCylMenu);
        
        // Initialiser l'état de l'interrupteur (Mock par défaut)
        setTimeout(() => {
          updateSwitchLabels();
          updateLeds(); // Initialiser les LEDs
        }, 100);
        
        // Ajouter un événement click sur l'interrupteur
        const switchElement = document.querySelector('.switch');
        const toggle = document.getElementById('dataToggle');
        
        if (switchElement && toggle) {
          switchElement.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            toggle.checked = !toggle.checked;
            toggleDataSource();
          });
        }
        
        // Afficher un message de confirmation
        setTimeout(() => {
          const status = document.querySelector('.status');
          if (status) {
            status.innerHTML = `
              <h3>✅ Système Opérationnel - ${new Date().toLocaleTimeString()}</h3>
              <p>Cette version fonctionne avec ou sans serveur HTTP et démontre l'architecture OOP refactorisée.</p>
              <p><strong>JavaScript chargé et fonctionnel !</strong></p>
              <p><strong>Menu cylindrique activé !</strong></p>
            `;
          }
        }, 100);
      });

      // === NOUVELLE PAGE HISTORIQUE ===

      // Variables globales pour la pagination historique
      let currentHistoriquePage = 1;
      let historiqueData = [];
      let totalHistoriquePages = 1;

      // Réinitialiser la page lors du changement de nombre de résultats
      function resetHistoriquePage() {
        currentHistoriquePage = 1;
        loadHistoriqueFromDatabase();
      }

      // Navigation entre les pages
      function gotoHistoriquePage(direction) {
        let newPage = currentHistoriquePage;
        
        switch(direction) {
          case 'first':
            newPage = 1;
            break;
          case 'prev':
            newPage = Math.max(1, currentHistoriquePage - 1);
            break;
          case 'next':
            newPage = Math.min(totalHistoriquePages, currentHistoriquePage + 1);
            break;
          case 'last':
            newPage = totalHistoriquePages;
            break;
          default:
            if (typeof direction === 'number') {
              newPage = Math.max(1, Math.min(totalHistoriquePages, direction));
            }
        }
        
        if (newPage !== currentHistoriquePage) {
          currentHistoriquePage = newPage;
          displayHistoriquePage();
        }
      }

      // Afficher la page actuelle
      function displayHistoriquePage() {
        const container = document.getElementById('tiragesContainer');
        const paginationSelect = document.getElementById('historiquePagination');
        const navigationDiv = document.getElementById('historiqueNavigation');
        const pageInfoSpan = document.getElementById('historiquePageInfo');
        
        if (!container || !historiqueData || historiqueData.length === 0) {
          return;
        }
        
        const pageSize = paginationSelect ? paginationSelect.value : '10';
        
        if (pageSize === 'all') {
          // Afficher tous les résultats
          container.innerHTML = historiqueData.map(draw => createTirageTag(draw)).join('');
          if (navigationDiv) navigationDiv.style.display = 'none';
          return;
        }
        
        const itemsPerPage = parseInt(pageSize);
        const startIndex = (currentHistoriquePage - 1) * itemsPerPage;
        const endIndex = startIndex + itemsPerPage;
        const pageData = historiqueData.slice(startIndex, endIndex);
        
        // Afficher les données de la page
        container.innerHTML = pageData.map(draw => createTirageTag(draw)).join('');
        
        // Mettre à jour les contrôles de navigation
        totalHistoriquePages = Math.ceil(historiqueData.length / itemsPerPage);
        
        // Toujours afficher les contrôles s'il y a des données, même pour 1 page
        if (historiqueData.length > 0 && navigationDiv) {
          navigationDiv.style.display = 'flex';
          if (pageInfoSpan) {
            pageInfoSpan.textContent = `Page ${currentHistoriquePage} sur ${totalHistoriquePages}`;
          }
          
          // Activer/désactiver les boutons
          const buttons = navigationDiv.querySelectorAll('.nav-btn');
          if (buttons.length === 4) {
            buttons[0].disabled = currentHistoriquePage === 1; // First
            buttons[1].disabled = currentHistoriquePage === 1; // Prev
            buttons[2].disabled = currentHistoriquePage === totalHistoriquePages; // Next
            buttons[3].disabled = currentHistoriquePage === totalHistoriquePages; // Last
          }
          
          // Ajouter info de pagination
          const infoDiv = document.createElement('div');
          infoDiv.style.cssText = 'text-align: center; color: #888; margin-top: 20px; font-size: 14px;';
          if (totalHistoriquePages > 1) {
            infoDiv.innerHTML = `📄 Affichage ${startIndex + 1}-${Math.min(endIndex, historiqueData.length)} sur ${historiqueData.length} tirages`;
          } else {
            infoDiv.innerHTML = `📄 ${historiqueData.length} tirage${historiqueData.length > 1 ? 's' : ''} au total`;
          }
          container.appendChild(infoDiv);
        } else if (navigationDiv) {
          navigationDiv.style.display = 'none';
        }
        
        console.log(`📄 Page ${currentHistoriquePage}/${totalHistoriquePages}: ${pageData.length} tirages affichés`);
      }

      // Fonction pour charger et afficher les tirages depuis la base
      async function loadHistoriqueFromDatabase() {
        console.log('🔄 Chargement de l\'historique depuis la base SQLite...');
        
        const container = document.getElementById('tiragesContainer');
        const paginationSelect = document.getElementById('historiquePagination');
        
        if (!container) {
          console.error('❌ Container tiragesContainer introuvable');
          return;
        }

        // Afficher un indicateur de chargement
        container.innerHTML = '<p class="loading-message">🔄 Chargement de l\'historique depuis la base SQLite...</p>';

        try {
          // Récupérer tous les tirages AVEC LES GAINS depuis l'API SQLite backend
          console.log('🌐 Requête API SQLite pour l\'historique avec gains...');
          const response = await fetch(`http://localhost:3001/api/tables/all`, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json'
            }
          });

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const result = await response.json();
          
          if (!result.success || !result.data) {
            throw new Error('Réponse API invalide ou données manquantes');
          }

          const joinedData = result.data;
          console.log(`📊 ${joinedData.length} lignes tirages+gains récupérées depuis SQLite`);

          if (joinedData.length === 0) {
            container.innerHTML = '<p class="no-data-message">Aucun tirage en base de données SQLite. Effectuez d\'abord un scraping depuis la page Tirage.</p>';
          return;
        }

          // Grouper les données par date de tirage (un tirage peut avoir plusieurs gains)
          const groupedByDate = {};
          
          joinedData.forEach(row => {
            const date = row.date;
            
            if (!groupedByDate[date]) {
              groupedByDate[date] = {
                date: date,
                source: row.tirage_source || 'SQLite',
                numbers: [],
                stars: [],
                gains: []
              };
              
              // Traitement des numéros
              if (row.numeros && typeof row.numeros === 'string' && row.numeros.trim() !== '') {
                groupedByDate[date].numbers = row.numeros.split(',').map(num => parseInt(num.trim(), 10)).filter(num => !isNaN(num));
              }

              // Traitement des étoiles
              if (row.etoiles && typeof row.etoiles === 'string' && row.etoiles.trim() !== '') {
                groupedByDate[date].stars = row.etoiles.split(',').map(star => parseInt(star.trim(), 10)).filter(star => !isNaN(star));
              }
            }
            
            // Ajouter le gain s'il existe (peut être null pour les tirages sans gains)
            if (row.rang && row.combinaison) {
              groupedByDate[date].gains.push({
                rang: row.combinaison,
                gagnants: row.nombre_gagnants || 0,
                gain: row.gain_unitaire || 'N/A',
                rankLabel: row.combinaison,
                winners: row.nombre_gagnants || 0,
                amount: row.gain_unitaire || 'N/A'
              });
            }
          });

          console.log('🔧 Données groupées par date:', Object.keys(groupedByDate).length, 'tirages uniques');
          
          // Convertir en tableau et ajouter les logs de gains
          const draws = Object.values(groupedByDate).map(draw => {
            console.log(`💰 Tirage ${draw.date}: ${draw.numbers.length} numéros, ${draw.stars.length} étoiles, ${draw.gains.length} gains`);
            if (draw.gains.length > 0) {
              console.log(`   💰 Gains détectés:`, draw.gains.map(g => `${g.rang}: ${g.gain}`).join(', '));
            } else {
              console.log(`   ⚠️ Aucun gain trouvé pour ce tirage`);
            }
            return draw;
          });

        // Trier par date (plus récent en premier)
        draws.sort((a, b) => new Date(b.date) - new Date(a.date));

        // Appliquer la pagination
        const pageSize = paginationSelect ? paginationSelect.value : '10';
        let drawsToDisplay = draws;
        
        if (pageSize !== 'all') {
          const limit = parseInt(pageSize);
          drawsToDisplay = draws.slice(0, limit);
          console.log(`📄 Affichage de ${drawsToDisplay.length}/${draws.length} tirages (limite: ${pageSize})`);
        } else {
          console.log(`📄 Affichage de tous les tirages (${draws.length})`);
        }

        // Générer le HTML des tags
        container.innerHTML = drawsToDisplay.map(draw => createTirageTag(draw)).join('');
        
        // Ajouter info de pagination si nécessaire
        if (pageSize !== 'all' && draws.length > parseInt(pageSize)) {
          const infoDiv = document.createElement('div');
          infoDiv.style.cssText = 'text-align: center; color: #888; margin-top: 20px; font-size: 14px;';
          infoDiv.innerHTML = `Affichage de ${drawsToDisplay.length} sur ${draws.length} tirages - Modifiez la sélection pour voir plus`;
          container.appendChild(infoDiv);
          }

          console.log('✅ Historique SQLite affiché avec succès');
          console.log('💰 Total gains chargés:', drawsToDisplay.reduce((total, draw) => total + draw.gains.length, 0));

        } catch (error) {
          console.error('❌ Erreur chargement historique SQLite:', error);
          
          // Fallback vers localStorage si API SQLite échoue
          console.log('🔄 Fallback vers localStorage...');
          await loadHistoriqueFromLocalStorage(container, paginationSelect);
        }
      }

      // Fonction fallback pour charger depuis localStorage
      async function loadHistoriqueFromLocalStorage(container, paginationSelect) {
        console.log('📂 Chargement historique depuis localStorage (fallback)...');
        
        try {
          // Récupérer tous les tirages depuis localStorage
          const draws = [];
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('draw_')) {
              try {
                const drawData = JSON.parse(localStorage.getItem(key));
                if (drawData && drawData.date) {
                  draws.push(drawData);
                }
              } catch (error) {
                console.warn('⚠️ Erreur parsing draw:', key, error);
              }
            }
          }

          console.log(`📊 ${draws.length} tirages trouvés en localStorage`);

          if (draws.length === 0) {
            container.innerHTML = '<p class="no-data-message">❌ Erreur de connexion SQLite et aucun tirage en localStorage. Vérifiez que le backend est démarré ou effectuez un scraping depuis la page Tirage.</p>';
            return;
          }

          // Trier par date (plus récent en premier)
          draws.sort((a, b) => new Date(b.date) - new Date(a.date));

          // Stocker les données pour la pagination (mode fallback)
          historiqueData = draws;
          currentHistoriquePage = 1;
          
          // Afficher la première page avec avertissement fallback
          displayHistoriquePage();
          
          // Note: Le displayHistoriquePage() ajoute déjà l'avertissement fallback
          
          // Ajouter info de pagination si nécessaire
          if (pageSize !== 'all' && draws.length > parseInt(pageSize)) {
            const infoDiv = document.createElement('div');
            infoDiv.style.cssText = 'text-align: center; color: #888; margin-top: 20px; font-size: 14px;';
            infoDiv.innerHTML = `Affichage de ${drawsToDisplay.length} sur ${draws.length} tirages - Modifiez la sélection pour voir plus`;
            container.appendChild(infoDiv);
          }

          console.log('✅ Historique localStorage affiché (fallback)');

        } catch (fallbackError) {
          console.error('❌ Erreur fallback localStorage:', fallbackError);
          container.innerHTML = '<p class="no-data-message">❌ Erreur: Impossible de charger l\'historique depuis SQLite et localStorage. Vérifiez la connexion backend et effectuez un scraping.</p>';
        }
      }

      // Créer un tag de tirage dépliable
      function createTirageTag(drawData) {
        const dateObj = new Date(drawData.date + 'T00:00:00');
        const formattedDate = dateObj.toLocaleDateString('fr-FR', {
          weekday: 'short',
          day: '2-digit',
          month: '2-digit',
          year: 'numeric'
        });

        // Créer les boules numéros
        const numberBalls = drawData.numbers.map(num => 
          `<span class="ball">${num}</span>`
        ).join('');

        // Créer les boules étoiles
        const starBalls = drawData.stars.map(star => 
          `<span class="ball star">${star}</span>`
        ).join('');

        // Créer les gains si disponibles
        const gainsHtml = createGainsHtml(drawData.gains || []);

        return `
          <div class="tirage-tag" data-date="${drawData.date}">
            <div class="tirage-tag-header" onclick="toggleTirageTag('${drawData.date}')">
              <div class="tirage-tag-info">
                <div class="tirage-date">${formattedDate}</div>
                <div class="tirage-numbers">
                  ${numberBalls}
                  ${starBalls}
                </div>
                <div class="tirage-source">${drawData.source || 'unknown'}</div>
              </div>
              <div class="tirage-expand-arrow">▼</div>
            </div>
            <div class="tirage-tag-content">
              <div class="tirage-gains">
                <div class="gains-title">Gains et Répartitions</div>
                ${gainsHtml}
              </div>
            </div>
          </div>
        `;
      }

      // Créer le HTML des gains
      function createGainsHtml(gains) {
        if (!gains || gains.length === 0) {
          return '<p style="color: #888; font-style: italic;">Aucun gain disponible pour ce tirage.</p>';
        }

        const gainsItems = gains.map(gain => {
          // Parser le rang pour créer les boules (ex: "5+2" → 5 boules + 2 étoiles)
          const rang = gain.rang || gain.rankLabel || '';
          const [numbers, stars] = rang.split('+').map(n => parseInt(n) || 0);
          
          // Créer les boules visuelles
          const numberBalls = Array.from({length: numbers}, (_, i) => 
            `<span class="ball">${i + 1}</span>`
          ).join('');
          
          const starBalls = Array.from({length: stars}, (_, i) => 
            `<span class="ball star">${i + 1}</span>`
          ).join('');

          return `
            <div class="gain-item">
              <div class="gain-combo">
                ${numberBalls}${starBalls}
              </div>
              <div class="gain-details">
                <div class="gain-amount">${gain.gain || gain.amount || 'N/A'}</div>
                <div class="gain-winners">${gain.gagnants || gain.winners || 0} gagnant(s)</div>
              </div>
            </div>
          `;
        }).join('');

        return `<div class="gains-grid">${gainsItems}</div>`;
      }

      // Basculer l'état déplié/plié d'un tag (générique)
      function toggleTirageTag(identifier) {
        console.log(`🎯 Clic détecté sur: ${identifier}`);
        let tag;
        
        // Si l'identifier est un ID, utiliser getElementById
        if (document.getElementById(identifier)) {
          tag = document.getElementById(identifier);
          console.log(`✅ Élément trouvé par ID: ${identifier}`);
        } else {
          // Sinon c'est une date, utiliser data-date (pour page Historique)
          tag = document.querySelector(`[data-date="${identifier}"]`);
          console.log(`✅ Élément trouvé par data-date: ${identifier}`);
        }
        
        if (tag) {
          const wasExpanded = tag.classList.contains('expanded');
          
          // Basculer la classe expanded
          tag.classList.toggle('expanded');
          
          // Basculer la flèche
          const arrow = tag.querySelector('.tirage-expand-arrow');
          if (arrow) {
            arrow.textContent = tag.classList.contains('expanded') ? '▲' : '▼';
            console.log(`🏹 Flèche changée: ${arrow.textContent}`);
          }
          
          // Basculer la LED si elle existe
          const led = tag.querySelector('.led_generique_petite');
          if (led) {
            if (tag.classList.contains('expanded')) {
              led.classList.remove('collapsed');
              led.classList.add('expanded');
            } else {
              led.classList.remove('expanded');
              led.classList.add('collapsed');
            }
            console.log(`💡 LED changée: ${led.classList.contains('expanded') ? 'verte' : 'grise'}`);
          }
          
          console.log(`🔄 Toggle ${identifier}: ${wasExpanded ? 'expanded' : 'collapsed'} → ${tag.classList.contains('expanded') ? 'expanded' : 'collapsed'}`);
        } else {
          console.error(`❌ Élément non trouvé pour: ${identifier}`);
        }
      }

      // Fonction pour initialiser la page historique
      function showHistorique() {
        showSection('demo');
        setTimeout(() => {
          loadHistoriqueFromDatabase();
        }, 100);
      }

      // === PAGE SCRAPING ===
      
      // Variables globales pour le scraping
      let scrapingInProgress = false;
      let scrapingAborted = false;
      let scrapingStats = {
        total: 0,
        processed: 0,
        success: 0,
        errors: 0
      };
      let selectedSourceFile = null;
      
      // Basculer entre mode date unique et intervalle
      function toggleScrapingMode() {
        const mode = document.querySelector('input[name="scrapingMode"]:checked').value;
        const singleControls = document.getElementById('singleDateControls');
        const rangeControls = document.getElementById('rangeDateControls');
        
        if (mode === 'single') {
          singleControls.style.display = 'flex';
          rangeControls.style.display = 'none';
          updateScrapingBreadcrumb('Mode: Date unique');
        } else {
          singleControls.style.display = 'none';
          rangeControls.style.display = 'flex';
          updateScrapingBreadcrumb('Mode: Intervalle de dates');
        }
      }
      
      // Changer la date de scraping (mode date unique)
      function changeScrapingDate(delta) {
        const dateInput = document.getElementById('scrapingDate');
        const currentDate = new Date(dateInput.value);
        currentDate.setDate(currentDate.getDate() + delta);
        
        // Limiter entre 2004-01-01 et aujourd'hui
        const minDate = new Date('2004-01-01');
        const maxDate = new Date();
        
        if (currentDate >= minDate && currentDate <= maxDate) {
          dateInput.value = currentDate.toISOString().split('T')[0];
          updateScrapingBreadcrumb(`Date sélectionnée: ${dateInput.value}`);
        }
      }
      
      // Mettre à jour le fil d'Ariane
      function updateScrapingBreadcrumb(text) {
        const breadcrumbText = document.getElementById('scrapingBreadcrumbText');
        if (breadcrumbText) {
          breadcrumbText.textContent = text;
        }
      }
      

      
      // Lancer le scraping
      async function startScraping() {
        console.log('🎯 [MAIN] === DÉBUT startScraping() ===');
        
        if (scrapingInProgress) {
          console.log('⚠️ [MAIN] Scraping déjà en cours, abandon');
          alert('Un scraping est déjà en cours');
          return;
        }
        
        const mode = document.querySelector('input[name="scrapingMode"]:checked').value;
        let dates = [];
        
        if (mode === 'single') {
          dates = [document.getElementById('scrapingDate').value];
        } else {
          const fromDate = new Date(document.getElementById('scrapingDateFrom').value);
          const toDate = new Date(document.getElementById('scrapingDateTo').value);
          
          const current = new Date(fromDate);
          while (current <= toDate) {
            const dayOfWeek = current.getDay();
            if (dayOfWeek === 2 || dayOfWeek === 5) {
              dates.push(current.toISOString().split('T')[0]);
            }
            current.setDate(current.getDate() + 1);
          }
        }
        
        console.log('📊 [MAIN] Dates générées:', dates);
        console.log('📊 [MAIN] Nombre de dates:', dates.length);
        
        if (dates.length === 0) {
          console.log('❌ [MAIN] Aucune date valide, abandon');
          alert('Aucune date valide à scraper');
          return;
        }
        
        // Confirmer le lancement
        console.log('❓ [MAIN] Demande confirmation utilisateur');
        const confirm = window.confirm(`Lancer le scraping de ${dates.length} date(s) ?\nCela peut prendre du temps.`);
        if (!confirm) {
          console.log('❌ [MAIN] Utilisateur a annulé');
          return;
        }
        console.log('✅ [MAIN] Utilisateur a confirmé');
        
        // Initialiser le scraping
        scrapingInProgress = true;
        scrapingAborted = false;
        scrapingStats = {
          total: dates.length,
          processed: 0,
          success: 0,
          errors: 0
        };
        
        // Afficher les sections de progression et résultats
        document.getElementById('scrapingProgressSection').style.display = 'block';
        document.getElementById('scrapingResultsSection').style.display = 'block';
        
        // Mettre à jour l'interface
        document.getElementById('stopScrapingBtn').style.display = 'inline-block';
        updateScrapingBreadcrumb(`Scraping en cours: 0/${dates.length}`);
        
        // Configuration
        const delay = parseInt(document.getElementById('scrapingDelay').value);
        const skipExisting = document.getElementById('skipExisting').checked;
        
        // Lancer le scraping
        console.log(`🎯 [BATCH] === DÉBUT BOUCLE SCRAPPING ===`);
        console.log(`🎯 [BATCH] Nombre de dates à traiter: ${dates.length}`);
        console.log(`🎯 [BATCH] Configuration - Délai: ${delay}ms, Skip existing: ${skipExisting}`);
        
        for (let i = 0; i < dates.length && !scrapingAborted; i++) {
          const date = dates[i];
          console.log(`🔄 [BATCH] --- Traitement ${i+1}/${dates.length}: ${date} ---`);
          
          try {
            addProgressLog(`📅 Scraping ${date}...`, 'info');
            console.log(`🎯 [BATCH] === DÉBUT TRAITEMENT DATE ${date} (${i+1}/${dates.length}) ===`);
            
            // Vérifier si existe déjà (si option activée)
            if (skipExisting) {
              console.log(`🔍 [BATCH] Vérification existence en base pour ${date}`);
              const existing = await checkDrawInSQLiteDatabase(date);
              console.log(`📊 [BATCH] Résultat vérification:`, existing);
              
              if (existing && !isEmptyDrawSQLite(existing)) {
                console.log(`⏭️ [BATCH] ${date} déjà en base, ignoré`);
                addProgressLog(`⏭️ ${date} déjà en base, ignoré`, 'warning');
                scrapingStats.processed++;
                updateScrapingProgress();
                continue;
              } else {
                console.log(`✅ [BATCH] ${date} pas en base ou vide, scrapping nécessaire`);
              }
            } else {
              console.log(`🔄 [BATCH] Option skipExisting désactivée, scrapping direct pour ${date}`);
            }
            
            // Effectuer le scraping (utiliser la stratégie Force de la page tirage)
            console.log(`🚀 [BATCH] Lancement scrapForScrappingPage pour ${date}`);
            const result = await scrapForScrappingPage(date);
            console.log(`📊 [BATCH] Résultat scrapForScrappingPage:`, result);
            
            if (result.noDrawDate) {
              console.log(`⭕ [BATCH] Date ${date} marquée comme "pas de tirage"`);
              addProgressLog(`⭕ ${date} marqué comme "pas de tirage"`, 'warning');
            } else {
              console.log(`✅ [BATCH] Date ${date} scrapée avec succès`);
              addProgressLog(`✅ ${date} scrapé avec succès`, 'success');
            }
            
            scrapingStats.success++;
            console.log(`📈 [BATCH] Stats mis à jour - Success: ${scrapingStats.success}`);
            
          } catch (error) {
            console.error(`❌ [BATCH] === ERREUR POUR DATE ${date} ===`);
            console.error(`❌ [BATCH] Message:`, error.message);
            console.error(`❌ [BATCH] Stack:`, error.stack);
            
            scrapingStats.errors++;
            addProgressLog(`❌ Erreur pour ${date}: ${error.message}`, 'error');
            console.log(`📉 [BATCH] Stats mis à jour - Errors: ${scrapingStats.errors}`);
          }
          
          scrapingStats.processed++;
          updateScrapingProgress();
          
          // Délai entre les requêtes
          if (i < dates.length - 1 && !scrapingAborted) {
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
        
        // Finaliser
        scrapingInProgress = false;
        document.getElementById('stopScrapingBtn').style.display = 'none';
        
        if (scrapingAborted) {
          updateScrapingBreadcrumb('Scraping interrompu');
          addProgressLog('🛑 Scraping interrompu par l\'utilisateur', 'warning');
        } else {
          updateScrapingBreadcrumb(`Scraping terminé: ${scrapingStats.success}/${scrapingStats.total} réussis`);
          addProgressLog('🎉 Scraping terminé avec succès', 'success');
        }
        
        // Mettre à jour les résultats finaux
        updateScrapingResults();
      }
      
      // Arrêter le scraping
      function stopScraping() {
        scrapingAborted = true;
        updateScrapingBreadcrumb('Arrêt du scraping...');
      }
      
      // Mettre à jour la progression
      function updateScrapingProgress() {
        const percent = Math.round((scrapingStats.processed / scrapingStats.total) * 100);
        
        document.getElementById('progressPercent').textContent = `${percent}%`;
        document.getElementById('progressProcessed').textContent = scrapingStats.processed;
        document.getElementById('progressSuccess').textContent = scrapingStats.success;
        document.getElementById('progressErrors').textContent = scrapingStats.errors;
        document.getElementById('progressBar').style.width = `${percent}%`;
        
        updateScrapingBreadcrumb(`Scraping: ${scrapingStats.processed}/${scrapingStats.total} (${percent}%)`);
      }
      
      // Ajouter un log de progression
      function addProgressLog(message, type = 'info') {
        const progressLog = document.getElementById('progressLog');
        const timestamp = new Date().toLocaleTimeString();
        
        let className = '';
        switch(type) {
          case 'error': className = 'log-error'; break;
          case 'success': className = 'log-success'; break;
          case 'warning': className = 'log-warning'; break;
          default: className = 'log-info'; break;
        }
        
        const logEntry = document.createElement('div');
        logEntry.className = `log-entry ${className}`;
        logEntry.innerHTML = `<span class="log-time">[${timestamp}]</span> ${message}`;
        
        progressLog.appendChild(logEntry);
        progressLog.scrollTop = progressLog.scrollHeight;
      }
      
      // Mettre à jour les résultats finaux
      function updateScrapingResults() {
        const resultsStats = document.getElementById('scrapingResultsStats');
        const successRate = Math.round((scrapingStats.success / scrapingStats.total) * 100);
        
        resultsStats.innerHTML = `
          <div class="result-stat">
            <span class="stat-label">Total traité:</span>
            <span class="stat-value">${scrapingStats.processed}/${scrapingStats.total}</span>
          </div>
          <div class="result-stat">
            <span class="stat-label">Réussis:</span>
            <span class="stat-value success">${scrapingStats.success}</span>
          </div>
          <div class="result-stat">
            <span class="stat-label">Erreurs:</span>
            <span class="stat-value error">${scrapingStats.errors}</span>
          </div>
          <div class="result-stat">
            <span class="stat-label">Taux de réussite:</span>
            <span class="stat-value">${successRate}%</span>
          </div>
        `;
      }
      
      // Fonctions de bascule des sections
      function toggleScrapingConfig() {
        toggleSection('configContent', 'configToggle', 'config-led');
      }
      

      
      function toggleScrapingProgress() {
        toggleSection('progressContent', 'progressToggle', 'progress-led');
      }
      
      function toggleScrapingResults() {
        toggleSection('resultsContent', 'resultsToggle', 'results-led');
      }
      
      // Fonction spécifique pour scraper et sauvegarder en SQLite (pour la page scrapping)
      async function scrapForScrappingPage(selectedDate) {
        console.log('🎯 [SCRAPPING] === DÉBUT SCRAPPING POUR:', selectedDate, '===');
        
        try {
          // ÉTAPE 1: Scraping des données
          console.log('🌐 [SCRAPPING] Étape 1: Lancement scraping pour', selectedDate);
          const scrapedData = await scrapDrawFromLotteryExtreme(selectedDate);
          console.log('📊 [SCRAPPING] Données scrappées reçues:', scrapedData);
          
          if (scrapedData && scrapedData.numbers && scrapedData.stars) {
            console.log('✅ [SCRAPPING] Données valides détectées:');
            console.log('   - Numéros:', scrapedData.numbers);
            console.log('   - Étoiles:', scrapedData.stars);
            console.log('   - Breakdown:', scrapedData.breakdown);
            
            // ÉTAPE 2: Préparation des données SQLite (tirages + gains)
            console.log('🔧 [SCRAPPING] Étape 2: Préparation données pour SQLite');
            
            // Traitement des gains depuis breakdown
            let gainsForSQLite = [];
            if (scrapedData.breakdown && Array.isArray(scrapedData.breakdown)) {
              console.log('💰 [SCRAPPING] Traitement des gains, breakdown trouvé:', scrapedData.breakdown.length, 'entrées');
              gainsForSQLite = scrapedData.breakdown.map((item, index) => {
                const gain = {
                  rang: item.rankLabel || `Rang ${index + 1}`,
                  combinaison: item.rankLabel || `${item.match || 'Inconnu'}`,
                  nombre_gagnants: item.winners || 0,
                  gain_unitaire: item.amount || '0 €'
                };
                console.log(`💰 [SCRAPPING] Gain ${index + 1}:`, gain);
                return gain;
              });
              console.log('💰 [SCRAPPING] Total gains formatés:', gainsForSQLite.length);
            } else {
              console.log('⚠️ [SCRAPPING] Aucun breakdown trouvé, pas de gains à sauvegarder');
            }
            
            const dataForSQLite = {
              date: selectedDate,
              numeros: scrapedData.numbers.join(','),
              etoiles: scrapedData.stars.join(','),
              source: 'scraped-bulk',
              gains: gainsForSQLite
            };
            console.log('📋 [SCRAPPING] Données préparées pour SQLite:');
            console.log('   - Date:', dataForSQLite.date);
            console.log('   - Numéros:', dataForSQLite.numeros);
            console.log('   - Étoiles:', dataForSQLite.etoiles);
            console.log('   - Source:', dataForSQLite.source);
            console.log('   - Gains:', dataForSQLite.gains.length, 'entrées');
            console.log('   - Détail gains:', dataForSQLite.gains);
            
            // ÉTAPE 3: Test de connectivité API
            console.log('🔍 [SCRAPPING] Étape 3: Test connectivité API backend...');
            try {
              const pingResponse = await fetch('http://localhost:3001/api/test-connection', {
                method: 'GET',
                headers: { 'Content-Type': 'application/json' }
              });
              console.log('📡 [SCRAPPING] Test connectivité - Status:', pingResponse.status, pingResponse.statusText);
            } catch (connectError) {
              console.error('❌ [SCRAPPING] ERREUR CONNECTIVITÉ:', connectError.message);
              throw new Error(`Backend inaccessible: ${connectError.message}`);
            }
            
            // ÉTAPE 4: Sauvegarde en SQLite via API backend
            console.log('💾 [SCRAPPING] Étape 4: Sauvegarde en SQLite via API POST');
            console.log('📤 [SCRAPPING] URL:', 'http://localhost:3001/api/tirages');
            console.log('📤 [SCRAPPING] Method: POST');
            console.log('📤 [SCRAPPING] Headers:', { 'Content-Type': 'application/json' });
            console.log('📤 [SCRAPPING] Body:', JSON.stringify(dataForSQLite));
            
            const response = await fetch('http://localhost:3001/api/tirages', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(dataForSQLite)
            });
            
            console.log('📥 [SCRAPPING] Réponse API reçue:');
            console.log('   - Status:', response.status);
            console.log('   - StatusText:', response.statusText);
            console.log('   - OK:', response.ok);
            console.log('   - Headers:', [...response.headers.entries()]);
            
            if (!response.ok) {
              const errorText = await response.text();
              console.error('❌ [SCRAPPING] Erreur réponse API:', errorText);
              throw new Error(`Erreur sauvegarde SQLite: ${response.status} ${response.statusText} - ${errorText}`);
            }
            
            // ÉTAPE 5: Traitement de la réponse
            console.log('🔍 [SCRAPPING] Étape 5: Traitement réponse API');
            const responseText = await response.text();
            console.log('📄 [SCRAPPING] Réponse brute:', responseText);
            
            let result;
            try {
              result = JSON.parse(responseText);
              console.log('📊 [SCRAPPING] Réponse parsée:', result);
            } catch (parseError) {
              console.error('❌ [SCRAPPING] Erreur parsing réponse:', parseError.message);
              throw new Error(`Réponse API invalide: ${responseText}`);
            }
            
            if (!result.success) {
              console.error('❌ [SCRAPPING] API retourne échec:', result);
              throw new Error(`Erreur API SQLite: ${result.error || 'Inconnue'}`);
            }
            
            console.log('🎉 [SCRAPPING] === SUCCÈS COMPLET ===');
            console.log('💾 [SCRAPPING] Données sauvegardées en SQLite pour', selectedDate);
            console.log('💾 [SCRAPPING] Tirage + ', gainsForSQLite.length, 'gains sauvegardés');
            console.log('📊 [SCRAPPING] Résultat final:', result);
            
            return { success: true, data: scrapedData };
            
          } else {
            console.error('❌ [SCRAPPING] Données invalides reçues:', scrapedData);
            throw new Error(`Aucune donnée valide récupérée pour ${selectedDate}`);
          }
          
        } catch (error) {
          console.error('❌ [SCRAPPING] === ERREUR GLOBALE ===');
          console.error('❌ [SCRAPPING] Date:', selectedDate);
          console.error('❌ [SCRAPPING] Message:', error.message);
          console.error('❌ [SCRAPPING] Stack:', error.stack);
          
          // Gestion spéciale des erreurs de validation
          if (error.message === 'NOT_DRAW_DAY') {
            console.log('⚠️ [SCRAPPING] Gestion: Pas un jour de tirage');
            throw new Error(`${selectedDate} n'est pas un jour de tirage (mardi/vendredi)`);
          } else if (error.message === 'FUTURE_DATE') {
            console.log('⚠️ [SCRAPPING] Gestion: Date future');
            throw new Error(`${selectedDate} est une date future`);
          } else if (error.message === 'NO_DRAW_THIS_DATE') {
            console.log('⚠️ [SCRAPPING] Gestion: Pas de tirage cette date');
            
            // Sauvegarder un tirage vide en SQLite pour marquer la date comme "pas de tirage"
            try {
              console.log('📝 [SCRAPPING] Tentative marquage "pas de tirage" en SQLite');
              const emptyData = {
                date: selectedDate,
                numeros: '',
                etoiles: '',
                source: 'no-draw',
                gains: []
              };
              console.log('📝 [SCRAPPING] Données vides pour SQLite:', emptyData);
              
              const response = await fetch('http://localhost:3001/api/tirages', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(emptyData)
              });
              
              console.log('📝 [SCRAPPING] Réponse marquage vide:', response.status, response.statusText);
              
              if (response.ok) {
                console.log('✅ [SCRAPPING] Marqué comme "pas de tirage" en SQLite pour', selectedDate);
                return { success: true, noDrawDate: true };
              } else {
                const errorText = await response.text();
                console.error('❌ [SCRAPPING] Erreur marquage vide:', errorText);
              }
            } catch (saveError) {
              console.error('❌ [SCRAPPING] Exception marquage vide:', saveError.message);
            }
            
            throw new Error(`Pas de tirage le ${selectedDate}`);
          } else {
            console.log('🔄 [SCRAPPING] Re-lancement erreur original');
            throw error;
          }
        }
      }
      
      // Fonction générique pour basculer les sections
      function toggleSection(contentId, toggleId, ledId) {
        const content = document.getElementById(contentId);
        const toggle = document.getElementById(toggleId);
        const led = document.getElementById(ledId);
        
        if (content.classList.contains('expanded')) {
          content.classList.remove('expanded');
          toggle.textContent = '▼';
          toggle.classList.remove('expanded');
          led.classList.remove('expanded');
          led.classList.add('collapsed');
        } else {
          content.classList.add('expanded');
          toggle.textContent = '▲';
          toggle.classList.add('expanded');
          led.classList.remove('collapsed');
          led.classList.add('expanded');
        }
      }
      
      // Gestion du sélecteur de fichier source
      function handleSourceFileSelect(event) {
        const file = event.target.files[0];
        const fileName = document.getElementById('sourceFileName');
        
        if (file) {
          selectedSourceFile = file;
          fileName.textContent = `📄 ${file.name} (${(file.size / 1024).toFixed(1)} KB)`;
          fileName.classList.add('selected');
          
          console.log('📁 [FICHIER] Fichier source sélectionné:', {
            name: file.name,
            size: file.size,
            type: file.type,
            lastModified: new Date(file.lastModified).toLocaleString()
          });
          
          // Détection du type de fichier et traitement automatique
          if (file.name.toLowerCase().endsWith('.csv')) {
            // Fichier CSV EuroMillions détecté
            fileName.textContent = `📊 ${file.name} (CSV EuroMillions - ${(file.size / 1024).toFixed(1)} KB)`;
            updateScrapingBreadcrumb(`📊 Fichier CSV EuroMillions détecté: ${file.name}`);
            
            // Proposer l'import automatique
            if (confirm(`🎯 Fichier CSV EuroMillions détecté !\n\nVoulez-vous importer automatiquement les tirages manquants depuis ce fichier ?\n\n✅ Cliquez OK pour lancer l'import\n❌ Cliquez Annuler pour sélectionner un autre fichier`)) {
              importCSVFileAuto(file);
            }
          } else {
            updateScrapingBreadcrumb(`📁 Fichier source: ${file.name} sélectionné`);
            
            // Prévisualiser le contenu si c'est un fichier texte/JSON
            if (file.type === 'application/json' || file.type === 'text/plain' || file.name.endsWith('.json') || file.name.endsWith('.txt')) {
              previewSourceFile(file);
            }
          }
        } else {
          selectedSourceFile = null;
          fileName.textContent = 'Aucun fichier sélectionné';
          fileName.classList.remove('selected');
          updateScrapingBreadcrumb('Prêt pour le scraping');
        }
      }
      
      // Import automatique de fichier CSV
      async function importCSVFileAuto(file) {
        console.log('🚀 [AUTO-IMPORT] Lancement import automatique CSV');
        updateScrapingBreadcrumb(`⏳ Import en cours: ${file.name}...`);
        
        try {
          const stats = await handleCSVImport(file);
          
          if (stats.error) {
            alert(`❌ Erreur import:\n\n${stats.error}`);
            updateScrapingBreadcrumb(`❌ Erreur: ${stats.error}`);
          } else {
            // Afficher les résultats
            const message = `✅ Import CSV terminé !\n\n📊 Statistiques:\n• Total lignes CSV: ${stats.total}\n• Nouveaux imports: ${stats.imported}\n• Déjà en base: ${stats.skipped}\n• Erreurs: ${stats.errors}`;
            
            alert(message);
            updateScrapingBreadcrumb(`✅ Import terminé: ${stats.imported}/${stats.total} nouveaux tirages`);
            
            // Actualiser la page Historique si elle existe
            if (typeof loadHistoriqueFromDatabase === 'function') {
              console.log('🔄 [AUTO-IMPORT] Actualisation page Historique...');
              setTimeout(() => {
                loadHistoriqueFromDatabase();
              }, 1000);
            }
          }
        } catch (error) {
          console.error('❌ [AUTO-IMPORT] Erreur critique:', error);
          alert(`❌ Erreur critique import:\n\n${error.message}`);
          updateScrapingBreadcrumb(`❌ Erreur critique: ${error.message}`);
        }
      }
      
      // Prévisualisation optionnelle du fichier source
      function previewSourceFile(file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const content = e.target.result;
            console.log('📄 [FICHIER] Aperçu du contenu (premiers 500 caractères):');
            console.log(content.substring(0, 500) + (content.length > 500 ? '...' : ''));
            
            // Si c'est du JSON, valider la structure
            if (file.name.endsWith('.json')) {
              const jsonData = JSON.parse(content);
              console.log('✅ [FICHIER] JSON valide détecté, structure:', Object.keys(jsonData));
            }
          } catch (error) {
            console.warn('⚠️ [FICHIER] Erreur lecture fichier:', error.message);
          }
        };
        reader.readAsText(file);
      }

      // === ARCHITECTURE - DOCUMENTATION PAGE ===

      // État des sections Architecture
      const architectureSectionsState = {
        structure: true,     // Déployée par défaut
        documentation: true  // Déployée par défaut
      };

      // Basculer l'état d'une section Architecture
      function toggleArchitectureSection(sectionName) {
        const content = document.getElementById(`${sectionName}-content`);
        const led = document.getElementById(`${sectionName}-led`);
        const arrow = document.getElementById(`${sectionName}-arrow`);
        
        if (!content || !led || !arrow) {
          console.error('❌ Éléments Architecture introuvables pour:', sectionName);
          return;
        }

        // Basculer l'état
        architectureSectionsState[sectionName] = !architectureSectionsState[sectionName];
        const isExpanded = architectureSectionsState[sectionName];
        
        // Mettre à jour les classes
        if (isExpanded) {
          content.classList.add('expanded');
          led.classList.remove('collapsed');
          led.classList.add('expanded');
          arrow.classList.add('expanded');
        } else {
          content.classList.remove('expanded');
          led.classList.remove('expanded');
          led.classList.add('collapsed');
          arrow.classList.remove('expanded');
        }
        
        // Mettre à jour le texte de la flèche (▼ pour déplier, ▲ pour replier)
        arrow.textContent = isExpanded ? '▲' : '▼';
        
        // Mettre à jour les classes des flèches
        if (isExpanded) {
          arrow.classList.add('expanded');
          arrow.classList.remove('collapsed');
        } else {
          arrow.classList.add('collapsed');
          arrow.classList.remove('expanded');
        }
        
        console.log(`🔄 Section Architecture '${sectionName}' ${isExpanded ? 'déployée' : 'pliée'}`);
      }

      // Initialiser les LEDs Architecture au chargement de la page
      function initializeArchitectureLEDs() {
        Object.keys(architectureSectionsState).forEach(sectionName => {
          const content = document.getElementById(`${sectionName}-content`);
          const led = document.getElementById(`${sectionName}-led`);
          const arrow = document.getElementById(`${sectionName}-arrow`);
          
          if (content && led && arrow) {
            const isExpanded = architectureSectionsState[sectionName];
            
            if (isExpanded) {
              content.classList.add('expanded');
              led.classList.add('expanded');
              arrow.classList.add('expanded');
              arrow.textContent = '▲';  // Flèche haute = déployé
            } else {
              led.classList.add('collapsed');
              arrow.classList.add('collapsed');
              arrow.textContent = '▼';  // Flèche bas = fermé
            }
          }
        });
      }

      // === FONCTIONS ADMIN MONITORING ===
      
      // Fonctions SQLite
      async function loadSQLiteTableData() {
        const tableSelector = document.getElementById('sqliteTableSelector');
        const pageSize = document.getElementById('sqlitePageSize');
        const tableType = tableSelector.value;
        const limit = parseInt(pageSize.value);
        
        console.log(`📊 SQLite - Chargement table: ${tableType}, limite: ${limit}`);
        addDumpLog(`🔍 Chargement ${tableType} avec limite ${limit}...`, 'info');
        
        try {
          // Récupérer les données depuis SQLite backend ou client
          const data = await getSQLiteTableData(tableType);
          
          console.log(`📊 Données récupérées:`, data);
          addDumpLog(`📊 ${data.length} enregistrements récupérés pour ${tableType}`, 'info');
        
        // Afficher dans la section SQLite
        displaySQLiteTableData(data, limit, 1, tableType);
        } catch (error) {
          console.error('❌ Erreur chargement données:', error);
          addDumpLog(`❌ Erreur chargement ${tableType}: ${error.message}`, 'error');
          
          // Afficher un message d'erreur
          displaySQLiteTableData([], limit, 1, tableType);
        }
      }
      

      
      // Récupérer données SQLite
      async function getSQLiteTableData(tableType) {
        console.log(`🗄️ SQLite: Récupération ${tableType}`);
        addDumpLog(`📊 Récupération données table: ${tableType}`, 'info');
        
        // PRIORITÉ 1: Essayer le backend SQLite API d'abord
        try {
          console.log('🌐 Tentative récupération via Backend API...');
          const backendData = await getSQLiteBackendTableData(tableType);
          if (backendData && backendData.length > 0) {
            addDumpLog(`✅ Backend API: ${backendData.length} enregistrements récupérés`, 'success');
            return backendData;
          }
        } catch (error) {
          console.warn('⚠️ Backend API non disponible:', error);
          addDumpLog(`⚠️ Backend API erreur: ${error.message}`, 'warning');
        }
        
        // PRIORITÉ 2: SQLite côté client si disponible
        if (!sqliteInitialized || !sqliteDatabase) {
          console.warn('SQLite côté client non initialisé');
          addDumpLog('⚠️ SQLite côté client non initialisé, tentative mode fallback...', 'warning');
          
          // PRIORITÉ 3: Mode fallback localStorage
          if (sqliteFallbackMode) {
            return getSQLiteFallbackData(tableType);
          } else {
            addDumpLog('❌ Toutes les sources de données non disponibles', 'error');
            return [];
          }
        }
        
        try {
          let query = '';
          let columns = [];
          
          switch(tableType) {
            case 'tirages':
              // Correspondance avec la vraie structure des tables
              query = 'SELECT id, date, numbers, stars, jackpot, source, created_at FROM tirages ORDER BY date DESC';
              columns = ['id', 'date', 'numbers', 'stars', 'jackpot', 'source', 'created_at'];
              break;
              
            case 'gains':
              query = `
                SELECT g.id, t.date, g.rang, g.combinaison, g.gains, g.gagnants, t.source
                FROM gains g
                JOIN tirages t ON g.tirage_id = t.id
                ORDER BY t.date DESC, g.rang ASC
              `;
              columns = ['id', 'date', 'rang', 'combinaison', 'gains', 'gagnants', 'source'];
              break;
              
            case 'sources':
              // Utiliser les vrais noms de colonnes
              query = 'SELECT id, nom, url, actif, created_at FROM sources ORDER BY id';
              columns = ['id', 'nom', 'url', 'actif', 'created_at'];
              break;
              
            case 'config':
              // Utiliser les vrais noms de colonnes
              query = 'SELECT id, cle, valeur, description, created_at FROM config ORDER BY cle';
              columns = ['id', 'cle', 'valeur', 'description', 'created_at'];
              break;
              
            case 'all':
              // Afficher toutes les données des principales tables
              query = `
                SELECT 'tirage' as type, id, date, '' as detail, source, created_at FROM tirages
                UNION ALL
                SELECT 'gain' as type, g.id, t.date, g.combinaison || ': ' || g.gains || '€', t.source, g.id FROM gains g JOIN tirages t ON g.tirage_id = t.id
                UNION ALL
                SELECT 'source' as type, id, nom, url, actif, created_at FROM sources
                UNION ALL
                SELECT 'config' as type, id, cle, valeur, '', created_at FROM config
                ORDER BY created_at DESC
              `;
              columns = ['type', 'id', 'date_ou_nom', 'detail', 'source_ou_valeur', 'created_at'];
              break;
              
            default:
              console.warn(`Type de table non supporté: ${tableType}`);
              return [];
          }
          
          addDumpLog(`🔍 Exécution requête: ${query}`, 'query');
          const result = sqliteDatabase.exec(query);
          
          if (result.length === 0) {
            console.log(`Aucune donnée trouvée pour ${tableType}`);
            addDumpLog(`⚠️ Aucune donnée trouvée pour ${tableType}`, 'warning');
            return [];
          }
          
          addDumpLog(`✅ Requête exécutée: ${result[0].values.length} lignes trouvées`, 'result');
          
          // Convertir le résultat en format attendu
          const rows = result[0].values.map(row => {
            const obj = {};
            columns.forEach((col, index) => {
              obj[col] = row[index];
            });
            
            // Ajouter le type pour l'affichage
            if (tableType === 'gains') {
              obj.type = 'gain';
            } else if (tableType === 'tirages') {
              obj.type = 'draw';
            }
            
            return obj;
          });
          
          console.log(`✅ SQLite: ${rows.length} lignes récupérées pour ${tableType}`);
          return rows;
          
        } catch (error) {
          console.error(`Erreur récupération SQLite ${tableType}:`, error);
          addDumpLog(`❌ Erreur récupération ${tableType}: ${error.message}`, 'error');
          return [];
        }
      }
      

      
      // Affichage SQLite géré par sqlite-api.js
      // function displaySQLiteTableData() - SUPPRIMÉE : conflit avec sqlite-api.js
      // La fonction displaySQLiteTableData() est maintenant dans sqlite-api.js
      

      
      // Fonction générique d'affichage
      function displayGenericTableData(data, pageSize, page, tableType, statsId, tableId, sourceLabel) {
        const monitoringTable = document.getElementById(tableId);
        const monitoringStats = document.getElementById(statsId);
        
        if (!data || data.length === 0) {
          monitoringTable.innerHTML = '<p>Aucune donnée disponible.</p>';
          monitoringStats.innerHTML = '';
          return;
        }
        
        // Statistiques
        const totalItems = data.length;
        const drawCount = data.filter(item => item.type === 'draw').length;
        const gainCount = data.filter(item => item.type === 'gain').length;
        
        monitoringStats.innerHTML = `
          <div class="stats-container" style="display: flex; gap: 20px; margin-bottom: 15px; font-size: 14px; align-items: center;">
            <span style="background: rgba(128,128,128,0.2); padding: 5px 10px; border-radius: 5px; font-weight: bold;">
              ${sourceLabel}
            </span>
            <span style="background: rgba(52,152,219,0.2); padding: 5px 10px; border-radius: 5px;">
              📊 Total: ${totalItems}
            </span>
            ${drawCount > 0 ? `<span style="background: rgba(46,204,113,0.2); padding: 5px 10px; border-radius: 5px;">🎲 Tirages: ${drawCount}</span>` : ''}
            ${gainCount > 0 ? `<span style="background: rgba(241,196,15,0.2); padding: 5px 10px; border-radius: 5px;">💰 Gains: ${gainCount}</span>` : ''}
          </div>
        `;
        
        // Pagination
        const totalPages = Math.ceil(totalItems / pageSize);
        const startIndex = (page - 1) * pageSize;
        const endIndex = Math.min(startIndex + pageSize, totalItems);
        const pageData = data.slice(startIndex, endIndex);
        
        // Table
        let tableHTML = `<div style="max-height: 400px; overflow-y: auto; border: 1px solid rgba(255,255,255,0.2); border-radius: 5px;">`;
        tableHTML += `<table style="width: 100%; border-collapse: collapse; font-size: 12px;">`;
        
        // Header selon le type
        if (tableType === 'draws' || (tableType === 'all' && drawCount > 0)) {
          tableHTML += `
            <thead style="background: rgba(52,152,219,0.3); position: sticky; top: 0;">
              <tr>
                <th style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">Date</th>
                <th style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">Numéros</th>
                <th style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">Étoiles</th>
                <th style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">Source</th>
                <th style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">Gains</th>
              </tr>
            </thead>
          `;
        } else {
          tableHTML += `
            <thead style="background: rgba(241,196,15,0.3); position: sticky; top: 0;">
              <tr>
                <th style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">Date</th>
                <th style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">Combinaison</th>
                <th style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">Gagnants</th>
                <th style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">Gain</th>
                <th style="padding: 8px; border: 1px solid rgba(255,255,255,0.1);">Source</th>
              </tr>
            </thead>
          `;
        }
        
        tableHTML += '<tbody>';
        pageData.forEach(item => {
          tableHTML += '<tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">';
          if (item.type === 'draw') {
            tableHTML += `
              <td style="padding: 6px;">${item.date}</td>
              <td style="padding: 6px;">${item.numbers}</td>
              <td style="padding: 6px;">${item.stars}</td>
              <td style="padding: 6px;">${item.source}</td>
              <td style="padding: 6px;">${item.gains}</td>
            `;
          } else {
            tableHTML += `
              <td style="padding: 6px;">${item.date || 'N/A'}</td>
              <td style="padding: 6px;">${item.combinaison || item.rang || 'N/A'}</td>
              <td style="padding: 6px;">${item.gagnants || 0}</td>
              <td style="padding: 6px;">${item.gains || item.gain || 'N/A'}</td>
              <td style="padding: 6px;">${item.source || 'N/A'}</td>
            `;
          }
          tableHTML += '</tr>';
        });
        tableHTML += '</tbody></table></div>';
        
        // Pagination info
        if (totalPages > 1) {
          tableHTML += `
            <div style="margin-top: 10px; text-align: center; font-size: 12px;">
              Page ${page} sur ${totalPages} (${startIndex + 1}-${endIndex} sur ${totalItems})
            </div>
          `;
        }
        
        monitoringTable.innerHTML = tableHTML;
      }
      


      // Ajouter l'initialisation des LEDs Architecture lors de l'affichage de la section
      const originalShowSection = showSection;
      showSection = function(sectionName) {
        originalShowSection(sectionName);
        if (sectionName === 'scraping') {
          setTimeout(() => {
            // Initialiser la page scraping
            toggleScrapingMode(); // Configurer l'affichage initial
            updateScrapingBreadcrumb('Mode: Date unique');
          }, 100);
        }
        if (sectionName === 'admin-monitoring') {
          // Effacer le dump au chargement de la page monitoring
          clearDumpLog();
          
          // Ouvrir automatiquement la page par défaut avec sections dépliées
          setTimeout(() => {
            initializeMonitoringLEDs();
            
            // Initialisation autonome avec diagnostic automatique
            autoInitializeMonitoring();
          }, 100);
        }
        if (sectionName === 'tirage') {
          // Initialiser les LEDs de l'interrupteur quand on va sur la page Tirage
          setTimeout(updateLeds, 100);
        }
      };

      // Initialisation des LEDs au chargement de la page
      // === FONCTIONS CONFIGURATION IA ===
      
      // Variables globales supprimées - gestion via toggleSection générique
      
      // Sections IA maintenant gérées par toggleTirageTag() générique

      // Basculer visibilité clé API
      function toggleApiKeyVisibility(inputId) {
        const input = document.getElementById(inputId);
        const button = input.nextElementSibling;
        
        if (input.type === 'password') {
          input.type = 'text';
          button.textContent = 'Cacher';
        } else {
          input.type = 'password';
          button.textContent = 'Voir';
        }
      }
      
      // Mettre à jour la valeur de température
      function updateTemperatureValue(provider, value) {
        document.getElementById(`${provider}TempValue`).textContent = value;
      }
      
      // Test connexion OpenAI
      async function testOpenAIConnection() {
        const apiKey = document.getElementById('openaiApiKey').value;
        const model = document.getElementById('openaiModel').value;
        
        if (!apiKey.trim()) {
          showTestResult('openaiTestResult', 'Veuillez saisir une clé API', 'error');
          return;
        }
        
        showTestResult('openaiTestResult', 'Test de connexion en cours...', 'loading');
        
        console.log('🤖 [OpenAI] ========== DÉBUT TEST CONNEXION ==========');
        console.log('🔑 [OpenAI] Clé API longueur:', apiKey.length, 'caractères');
        console.log('🔑 [OpenAI] Clé API format:', apiKey.substring(0, 10) + '...' + apiKey.substring(apiKey.length - 4));
        console.log('🔧 [OpenAI] Modèle sélectionné:', model);
        console.log('🌐 [OpenAI] URL cible: https://api.openai.com/v1/chat/completions');
        console.log('🕐 [OpenAI] Timestamp:', new Date().toISOString());
        
        // Diagnostic environnement
        console.log('🔍 [OpenAI] DIAGNOSTIC ENVIRONNEMENT:');
        console.log('   - Navigator online:', navigator.onLine);
        console.log('   - User Agent:', navigator.userAgent);
        console.log('   - Location protocol:', window.location.protocol);
        console.log('   - Location host:', window.location.host);
        
        const requestBody = {
          model: model,
          messages: [{ role: 'user', content: 'Test de connexion. Répondez simplement "OK".' }],
          max_tokens: 10,
          temperature: 0.1
        };
        
        const requestHeaders = {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        };
        
        console.log('📦 [OpenAI] BODY REQUEST:', JSON.stringify(requestBody, null, 2));
        console.log('📡 [OpenAI] HEADERS REQUEST:', JSON.stringify(requestHeaders, null, 2));
        
        // Test de connectivité préliminaire
        console.log('🔍 [OpenAI] TEST CONNECTIVITÉ PRÉLIMINAIRE...');
        try {
          const pingResponse = await fetch('https://httpbin.org/get', { 
            method: 'GET',
            mode: 'cors'
          });
          console.log('✅ [OpenAI] Test connectivité httpbin.org:', pingResponse.status);
        } catch (pingError) {
          console.error('❌ [OpenAI] Échec test connectivité httpbin.org:', pingError);
        }
        
        // Mesure du temps de réponse
        const startTime = performance.now();
        
        try {
          console.log('🌐 [OpenAI] ENVOI REQUÊTE...');
          
          const fetchOptions = {
            method: 'POST',
            headers: requestHeaders,
            body: JSON.stringify(requestBody),
            mode: 'cors',
            credentials: 'omit',
            cache: 'no-cache'
          };
          
          console.log('⚙️ [OpenAI] Options fetch:', JSON.stringify(fetchOptions, null, 2));
          
          const response = await fetch('https://api.openai.com/v1/chat/completions', fetchOptions);
          
          const endTime = performance.now();
          const duration = endTime - startTime;
          
          console.log('📨 [OpenAI] RÉPONSE REÇUE:');
          console.log('   - Status Code:', response.status);
          console.log('   - Status Text:', response.statusText);
          console.log('   - Type:', response.type);
          console.log('   - URL:', response.url);
          console.log('   - Redirected:', response.redirected);
          console.log('   - Duration:', Math.round(duration), 'ms');
          
          const responseHeaders = {};
          for (let [key, value] of response.headers.entries()) {
            responseHeaders[key] = value;
          }
          console.log('📨 [OpenAI] Headers réponse:', JSON.stringify(responseHeaders, null, 2));
          
          if (response.ok) {
            const responseText = await response.text();
            console.log('📄 [OpenAI] Raw response:', responseText);
            
            const data = JSON.parse(responseText);
            console.log('✅ [OpenAI] Données structurées:', JSON.stringify(data, null, 2));
            
            const reply = data.choices[0].message.content.trim();
            showTestResult('openaiTestResult', `Connexion réussie ! Réponse: "${reply}" (${Math.round(duration)}ms)`, 'success');
            
            // Sauvegarder la clé API dans localStorage
            localStorage.setItem('openai_api_key', apiKey);
            localStorage.setItem('openai_model', model);
            console.log('💾 [OpenAI] Clé API sauvegardée');
          } else {
            console.error('❌ [OpenAI] ERREUR HTTP DÉTAILLÉE:');
            const errorText = await response.text();
            console.error('   - Status:', response.status);
            console.error('   - Status Text:', response.statusText);
            console.error('   - Response body:', errorText);
            
            try {
              const error = JSON.parse(errorText);
              console.error('   - Error object:', JSON.stringify(error, null, 2));
              showTestResult('openaiTestResult', `Erreur ${response.status}: ${error.error?.message || 'Connexion échouée'}`, 'error');
            } catch (parseError) {
              console.error('   - Parse error:', parseError);
              showTestResult('openaiTestResult', `Erreur ${response.status}: ${errorText}`, 'error');
            }
          }
        } catch (error) {
          const endTime = performance.now();
          const duration = endTime - startTime;
          
          console.error('❌ [OpenAI] ERREUR RÉSEAU COMPLÈTE:');
          console.error('   - Type:', error.name);
          console.error('   - Message:', error.message);
          console.error('   - Duration avant erreur:', Math.round(duration), 'ms');
          console.error('   - Stack trace:', error.stack);
          console.error('   - Error object complet:', error);
          
          // Lancer l'analyse rapide automatiquement
          console.log('🔍 Lancement analyse rapide automatique...');
          setTimeout(quickErrorAnalysis, 100);
          
          // Diagnostic approfondi des erreurs
          let diagnosticMessage = `Erreur réseau: ${error.message}\n`;
          diagnosticMessage += `Durée avant erreur: ${Math.round(duration)}ms\n\n`;
          
          if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
            diagnosticMessage += '🔍 DIAGNOSTIC DÉTAILLÉ "Failed to fetch":\n';
            
            // Diagnostic plus précis basé sur la durée
            if (duration < 50) {
              diagnosticMessage += '⚡ ERREUR IMMÉDIATE (<50ms):\n';
              diagnosticMessage += '➤ CAUSE PROBABLE: Extension navigateur ou blocage local\n';
              diagnosticMessage += '➤ SOLUTION: Désactiver AdBlock, uBlock, Privacy Badger\n\n';
            } else if (duration < 200) {
              diagnosticMessage += '🚫 ERREUR RAPIDE (<200ms):\n';
              diagnosticMessage += '➤ CAUSE PROBABLE: Firewall ou antivirus\n';
              diagnosticMessage += '➤ SOLUTION: Désactiver temporairement firewall/antivirus\n\n';
            } else if (duration > 5000) {
              diagnosticMessage += '🐌 ERREUR LENTE (>5s):\n';
              diagnosticMessage += '➤ CAUSE PROBABLE: Problème réseau ou DNS\n';
              diagnosticMessage += '➤ SOLUTION: Changer DNS (8.8.8.8) ou réseau\n\n';
            }
            
            diagnosticMessage += 'CAUSES COMMUNES:\n';
            diagnosticMessage += '1. 🛡️  Extensions navigateur (AdBlock, uBlock)\n';
            diagnosticMessage += '2. 🔥 Firewall Windows/Mac bloquant HTTPS\n';
            diagnosticMessage += '3. 🛡️  Antivirus analysant le trafic\n';
            diagnosticMessage += '4. 🌐 Proxy d\'entreprise mal configuré\n';
            diagnosticMessage += '5. 🔒 CORS - localhost HTTP vers HTTPS API\n\n';
            
            diagnosticMessage += '🔧 SOLUTIONS PAR ORDRE DE PRIORITÉ:\n';
            diagnosticMessage += '1. Ouvrir console (F12) → Rechercher détails erreur\n';
            diagnosticMessage += '2. Navigation privée (Ctrl+Shift+N)\n';
            diagnosticMessage += '3. Désactiver TOUTES les extensions\n';
            diagnosticMessage += '4. Tester avec Chrome/Firefox alternatif\n';
            diagnosticMessage += '5. Hotspot mobile pour tester réseau\n';
            diagnosticMessage += '6. Bouton "Diagnostic Réseau" pour analyse complète\n';
          }
          
          showTestResult('openaiTestResult', diagnosticMessage, 'error');
        }
        
        console.log('🤖 [OpenAI] ========== FIN TEST CONNEXION ==========');
      }
      
      // Test connexion Claude
      async function testClaudeConnection() {
        const apiKey = document.getElementById('claudeApiKey').value;
        const model = document.getElementById('claudeModel').value;
        
        if (!apiKey.trim()) {
          showTestResult('claudeTestResult', 'Veuillez saisir une clé API', 'error');
          return;
        }
        
        showTestResult('claudeTestResult', 'Test de connexion en cours...', 'loading');
        
        console.log('🤖 [Claude] Début test connexion');
        console.log('🔑 [Claude] Clé API:', apiKey.substring(0, 10) + '...');
        console.log('🔧 [Claude] Modèle:', model);
        
        const requestBody = {
          model: model,
          max_tokens: 10,
          messages: [{ role: 'user', content: 'Test de connexion. Répondez simplement "OK".' }]
        };
        
        const requestHeaders = {
          'x-api-key': apiKey,
          'Content-Type': 'application/json',
          'anthropic-version': '2023-06-01'
        };
        
        console.log('📡 [Claude] Headers:', requestHeaders);
        console.log('📦 [Claude] Body:', requestBody);
        
        try {
          console.log('🌐 [Claude] Envoi requête vers: https://api.anthropic.com/v1/messages');
          
          const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: requestHeaders,
            body: JSON.stringify(requestBody)
          });
          
          console.log('📨 [Claude] Réponse reçue - Status:', response.status);
          console.log('📨 [Claude] Headers réponse:', Object.fromEntries(response.headers.entries()));
          
          if (response.ok) {
            const data = await response.json();
            console.log('✅ [Claude] Données reçues:', data);
            const reply = data.content[0].text.trim();
            showTestResult('claudeTestResult', `Connexion réussie ! Réponse: "${reply}"`, 'success');
            
            // Sauvegarder la clé API dans localStorage
            localStorage.setItem('claude_api_key', apiKey);
            localStorage.setItem('claude_model', model);
            console.log('💾 [Claude] Clé API sauvegardée');
          } else {
            const errorText = await response.text();
            console.error('❌ [Claude] Erreur HTTP:', response.status, errorText);
            try {
              const error = JSON.parse(errorText);
              showTestResult('claudeTestResult', `Erreur ${response.status}: ${error.error?.message || 'Connexion échouée'}`, 'error');
            } catch {
              showTestResult('claudeTestResult', `Erreur ${response.status}: ${errorText}`, 'error');
            }
          }
        } catch (error) {
          console.error('❌ [Claude] Erreur réseau complète:', error);
          console.error('❌ [Claude] Type erreur:', error.name);
          console.error('❌ [Claude] Message erreur:', error.message);
          console.error('❌ [Claude] Stack:', error.stack);
          
          let errorMessage = `Erreur réseau: ${error.message}`;
          
          if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
            errorMessage += '\n🔍 Causes possibles:\n- Problème CORS\n- Connexion internet\n- Clé API invalide\n- Firewall/Proxy';
          }
          
          showTestResult('claudeTestResult', errorMessage, 'error');
        }
      }
      
      // Afficher résultat de test
      function showTestResult(elementId, message, type) {
        const element = document.getElementById(elementId);
        element.style.display = 'block';
        
        const colors = {
          loading: { bg: 'rgba(52, 152, 219, 0.1)', border: '#3498db', color: '#3498db' },
          success: { bg: 'rgba(46, 204, 113, 0.1)', border: '#2ecc71', color: '#2ecc71' },
          error: { bg: 'rgba(231, 76, 60, 0.1)', border: '#e74c3c', color: '#e74c3c' }
        };
        
        const style = colors[type] || colors.error;
        element.style.background = style.bg;
        element.style.border = `1px solid ${style.border}`;
        element.style.color = style.color;
        element.innerHTML = message;
        
        // Auto-hide après 5 secondes pour les succès
        if (type === 'success') {
          setTimeout(() => {
            element.style.display = 'none';
          }, 5000);
        }
      }
      
      // Test connexion Mistral
      async function testMistralConnection() {
        const apiKey = document.getElementById('mistralApiKey').value;
        const model = document.getElementById('mistralModel').value;
        
        if (!apiKey.trim()) {
          showTestResult('mistralTestResult', 'Veuillez saisir une clé API', 'error');
          return;
        }
        
        showTestResult('mistralTestResult', 'Test de connexion en cours...', 'loading');
        
        console.log('🤖 [Mistral] Début test connexion');
        console.log('🔑 [Mistral] Clé API:', apiKey.substring(0, 10) + '...');
        console.log('🔧 [Mistral] Modèle:', model);
        
        const requestBody = {
          model: model,
          messages: [{ role: 'user', content: 'Test de connexion. Répondez simplement "OK".' }],
          max_tokens: 10,
          temperature: 0.1
        };
        
        const requestHeaders = {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        };
        
        console.log('📡 [Mistral] Headers:', requestHeaders);
        console.log('📦 [Mistral] Body:', requestBody);
        
        try {
          console.log('🌐 [Mistral] Envoi requête vers: https://api.mistral.ai/v1/chat/completions');
          
          const response = await fetch('https://api.mistral.ai/v1/chat/completions', {
            method: 'POST',
            headers: requestHeaders,
            body: JSON.stringify(requestBody)
          });
          
          console.log('📨 [Mistral] Réponse reçue - Status:', response.status);
          console.log('📨 [Mistral] Headers réponse:', Object.fromEntries(response.headers.entries()));
          
          if (response.ok) {
            const data = await response.json();
            console.log('✅ [Mistral] Données reçues:', data);
            const reply = data.choices[0].message.content.trim();
            showTestResult('mistralTestResult', `Connexion réussie ! Réponse: "${reply}"`, 'success');
            
            // Sauvegarder la clé API dans localStorage
            localStorage.setItem('mistral_api_key', apiKey);
            localStorage.setItem('mistral_model', model);
            console.log('💾 [Mistral] Clé API sauvegardée');
          } else {
            const errorText = await response.text();
            console.error('❌ [Mistral] Erreur HTTP:', response.status, errorText);
            try {
              const error = JSON.parse(errorText);
              showTestResult('mistralTestResult', `Erreur ${response.status}: ${error.error?.message || 'Connexion échouée'}`, 'error');
            } catch {
              showTestResult('mistralTestResult', `Erreur ${response.status}: ${errorText}`, 'error');
            }
          }
        } catch (error) {
          console.error('❌ [Mistral] Erreur réseau complète:', error);
          console.error('❌ [Mistral] Type erreur:', error.name);
          console.error('❌ [Mistral] Message erreur:', error.message);
          console.error('❌ [Mistral] Stack:', error.stack);
          
          let errorMessage = `Erreur réseau: ${error.message}`;
          
          if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
            errorMessage += '\n🔍 Causes possibles:\n- Problème CORS\n- Connexion internet\n- Clé API invalide\n- Firewall/Proxy';
          }
          
          showTestResult('mistralTestResult', errorMessage, 'error');
        }
      }

      // === FONCTIONS SAUVEGARDE AUTOMATIQUE ===
      
      // Sauvegarder une clé API immédiatement
      function saveApiKey(provider, inputId) {
        const input = document.getElementById(inputId);
        if (input && input.value.trim()) {
          localStorage.setItem(`${provider}_api_key`, input.value.trim());
          console.log(`💾 [${provider.toUpperCase()}] Clé API sauvegardée automatiquement`);
          
          // Indicateur visuel de sauvegarde
          input.style.borderColor = '#2ecc71';
          setTimeout(() => {
            input.style.borderColor = '#9b59b6';
          }, 1000);
        }
      }
      
      // Sauvegarder un modèle immédiatement
      function saveApiModel(provider, value) {
        if (value) {
          localStorage.setItem(`${provider}_model`, value);
          console.log(`💾 [${provider.toUpperCase()}] Modèle sauvegardé: ${value}`);
        }
      }
      
      // Sauvegarder la température immédiatement
      function saveApiTemperature(provider, value) {
        if (value !== undefined) {
          localStorage.setItem(`${provider}_temperature`, value);
          console.log(`💾 [${provider.toUpperCase()}] Température sauvegardée: ${value}`);
        }
      }
      
      // Charger les configurations sauvegardées au démarrage
      function loadSavedConfigs() {
        console.log('🔄 Chargement des configurations sauvegardées...');
        
        // OpenAI
        const openaiKey = localStorage.getItem('openai_api_key');
        const openaiModel = localStorage.getItem('openai_model') || 'gpt-4o';
        const openaiTemp = localStorage.getItem('openai_temperature') || '0.7';
        if (openaiKey) {
          const input = document.getElementById('openaiApiKey');
          if (input) {
            input.value = openaiKey;
            console.log('✅ [OpenAI] Clé API rechargée');
          }
        }
        const openaiSelect = document.getElementById('openaiModel');
        if (openaiSelect) {
          openaiSelect.value = openaiModel;
          console.log('✅ [OpenAI] Modèle rechargé:', openaiModel);
        }
        // Température OpenAI supprimée de l'interface
        console.log('✅ [OpenAI] Configuration rechargée (température fixe: 0.7)');
        
        // Claude
        const claudeKey = localStorage.getItem('claude_api_key');
        const claudeModel = localStorage.getItem('claude_model') || 'claude-3-5-sonnet-20241022';
        const claudeTemp = localStorage.getItem('claude_temperature') || '0.7';
        if (claudeKey) {
          const input = document.getElementById('claudeApiKey');
          if (input) {
            input.value = claudeKey;
            console.log('✅ [Claude] Clé API rechargée');
          }
        }
        const claudeSelect = document.getElementById('claudeModel');
        if (claudeSelect) {
          claudeSelect.value = claudeModel;
          console.log('✅ [Claude] Modèle rechargé:', claudeModel);
        }
        // Température Claude supprimée de l'interface
        console.log('✅ [Claude] Configuration rechargée (température fixe: 0.7)');

        // Mistral
        const mistralKey = localStorage.getItem('mistral_api_key');
        const mistralModel = localStorage.getItem('mistral_model') || 'mistral-large-latest';
        const mistralTemp = localStorage.getItem('mistral_temperature') || '0.7';
        if (mistralKey) {
          const input = document.getElementById('mistralApiKey');
          if (input) {
            input.value = mistralKey;
            console.log('✅ [Mistral] Clé API rechargée');
          }
        }
        const mistralSelect = document.getElementById('mistralModel');
        if (mistralSelect) {
          mistralSelect.value = mistralModel;
          console.log('✅ [Mistral] Modèle rechargé:', mistralModel);
        }
        // Température Mistral supprimée de l'interface
        console.log('✅ [Mistral] Configuration rechargée (température fixe: 0.7)');
        
        console.log('🎯 Toutes les configurations ont été rechargées');
      }
      
      // Ouvrir la page de diagnostic
      function openDiagnosticPage() {
        window.open('diagnostic-ia.html', '_blank', 'width=1200,height=800');
      }
      
      // Fonction d'analyse rapide des erreurs sur la page principale
      function quickErrorAnalysis() {
        console.log('🔍 ========== ANALYSE RAPIDE DES ERREURS ==========');
        
        // Vérifier les conditions communes d'erreur
        const checks = [
          {
            name: 'Protocol HTTPS',
            test: () => window.location.protocol === 'https:',
            issue: 'Les APIs IA exigent HTTPS. Localhost HTTP peut causer "Failed to fetch".',
            solution: 'Utiliser un proxy HTTPS ou certificat SSL local'
          },
          {
            name: 'Connexion Internet',
            test: () => navigator.onLine,
            issue: 'Navigateur indique hors ligne',
            solution: 'Vérifier connexion réseau'
          },
          {
            name: 'LocalStorage Disponible',
            test: () => {
              try {
                localStorage.setItem('test', 'test');
                localStorage.removeItem('test');
                return true;
              } catch (e) { return false; }
            },
            issue: 'LocalStorage bloqué (navigation privée?)',
            solution: 'Désactiver navigation privée ou autoriser stockage'
          },
          {
            name: 'Fetch API Disponible',
            test: () => typeof fetch !== 'undefined',
            issue: 'API Fetch non supportée',
            solution: 'Mettre à jour le navigateur'
          }
        ];
        
        let issuesFound = 0;
        
        checks.forEach(check => {
          try {
            const result = check.test();
            if (result) {
              console.log(`✅ ${check.name}: OK`);
            } else {
              console.error(`❌ ${check.name}: PROBLÈME DÉTECTÉ`);
              console.error(`   Issue: ${check.issue}`);
              console.error(`   Solution: ${check.solution}`);
              issuesFound++;
            }
          } catch (error) {
            console.error(`❓ ${check.name}: Erreur test - ${error.message}`);
            issuesFound++;
          }
        });
        
        if (issuesFound === 0) {
          console.log('✅ Aucun problème majeur détecté. L\'erreur peut être due à:');
          console.log('   - Firewall/Antivirus bloquant les requêtes');
          console.log('   - Extensions navigateur (AdBlock, etc.)');
          console.log('   - Proxy/VPN mal configuré');
          console.log('   - Clé API invalide ou expirée');
        } else {
          console.log(`⚠️  ${issuesFound} problème(s) détecté(s). Corrigez-les avant de retester.`);
        }
        
        console.log('🔍 ========== FIN ANALYSE RAPIDE ==========');
      }

      // === FONCTIONS TEST QUESTIONS IA ===
      
      // Envoyer une question test à OpenAI
      async function sendOpenAIQuestion() {
        const apiKey = document.getElementById('openaiApiKey').value;
        const model = document.getElementById('openaiModel').value;
        const temperature = 0.7; // Température fixe
        
        if (!apiKey.trim()) {
          showTestResult('openaiTestResult', 'Veuillez d\'abord configurer votre clé API', 'error');
          return;
        }
        
        const question = "Analysez ces 5 numéros EuroMillions : 7, 14, 21, 28, 35 et les étoiles 3, 8. Donnez-moi des statistiques sur ces numéros et proposez une combinaison optimisée pour le prochain tirage.";
        
        showTestResult('openaiTestResult', 'Envoi de la question à OpenAI...', 'loading');
        
        console.log('🧠 [OpenAI Question] Début envoi question');
        console.log('🔧 [OpenAI Question] Température:', temperature);
        console.log('❓ [OpenAI Question] Question:', question);
        
        try {
          const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${apiKey}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              model: model,
              messages: [{ 
                role: 'user', 
                content: question
              }],
              max_tokens: 500,
              temperature: temperature
            })
          });
          
          console.log('📨 [OpenAI Question] Statut réponse:', response.status);
          
          if (response.ok) {
            const data = await response.json();
            console.log('✅ [OpenAI Question] Réponse reçue:', data);
            const reply = data.choices[0].message.content;
            showTestResult('openaiTestResult', `<strong>Question :</strong> ${question}<br><br><strong>Réponse OpenAI :</strong><br>${reply}`, 'success');
          } else {
            const errorText = await response.text();
            console.error('❌ [OpenAI Question] Erreur:', errorText);
            try {
              const error = JSON.parse(errorText);
              showTestResult('openaiTestResult', `Erreur ${response.status}: ${error.error?.message || 'Échec de la requête'}`, 'error');
            } catch {
              showTestResult('openaiTestResult', `Erreur ${response.status}: ${errorText}`, 'error');
            }
          }
        } catch (error) {
          console.error('❌ [OpenAI Question] Erreur réseau:', error);
          showTestResult('openaiTestResult', `Erreur réseau: ${error.message}`, 'error');
        }
      }
      
      // Envoyer une question test à Claude
      async function sendClaudeQuestion() {
        const apiKey = document.getElementById('claudeApiKey').value;
        const model = document.getElementById('claudeModel').value;
        const temperature = 0.7; // Température fixe
        
        if (!apiKey.trim()) {
          showTestResult('claudeTestResult', 'Veuillez d\'abord configurer votre clé API', 'error');
          return;
        }
        
        const question = "Analysez ces 5 numéros EuroMillions : 12, 19, 26, 33, 42 et les étoiles 5, 11. Quels sont les patterns statistiques de ces numéros et quelle stratégie recommanderiez-vous pour améliorer les chances au prochain tirage ?";
        
        showTestResult('claudeTestResult', 'Envoi de la question à Claude...', 'loading');
        
        try {
          const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: {
              'x-api-key': apiKey,
              'Content-Type': 'application/json',
              'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify({
              model: model,
              max_tokens: 500,
              messages: [{ 
                role: 'user', 
                content: question
              }],
              temperature: temperature
            })
          });
          
          if (response.ok) {
            const data = await response.json();
            const reply = data.content[0].text;
            showTestResult('claudeTestResult', `<strong>Question :</strong> ${question}<br><br><strong>Réponse Claude :</strong><br>${reply}`, 'success');
          } else {
            const error = await response.json();
            showTestResult('claudeTestResult', `Erreur ${response.status}: ${error.error?.message || 'Échec de la requête'}`, 'error');
          }
        } catch (error) {
          showTestResult('claudeTestResult', `Erreur réseau: ${error.message}`, 'error');
        }
      }
      
      // Envoyer une question test à Mistral
      async function sendMistralQuestion() {
        const apiKey = document.getElementById('mistralApiKey').value;
        const model = document.getElementById('mistralModel').value;
        const temperature = 0.7; // Température fixe
        
        if (!apiKey.trim()) {
          showTestResult('mistralTestResult', 'Veuillez d\'abord configurer votre clé API', 'error');
          return;
        }
        
        const question = "Analysez ces 5 numéros EuroMillions : 3, 17, 24, 31, 47 et les étoiles 2, 9. Pouvez-vous identifier des tendances dans ces numéros et suggérer une approche mathématique pour optimiser les futures combinaisons ?";
        
        showTestResult('mistralTestResult', 'Envoi de la question à Mistral...', 'loading');
        
        try {
          const response = await fetch('https://api.mistral.ai/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${apiKey}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              model: model,
              messages: [{ 
                role: 'user', 
                content: question
              }],
              max_tokens: 500,
              temperature: temperature
            })
          });
          
          if (response.ok) {
            const data = await response.json();
            const reply = data.choices[0].message.content;
            showTestResult('mistralTestResult', `<strong>Question :</strong> ${question}<br><br><strong>Réponse Mistral :</strong><br>${reply}`, 'success');
          } else {
            const error = await response.json();
            showTestResult('mistralTestResult', `Erreur ${response.status}: ${error.error?.message || 'Échec de la requête'}`, 'error');
          }
        } catch (error) {
          showTestResult('mistralTestResult', `Erreur réseau: ${error.message}`, 'error');
        }
      }

      // Nouvelles fonctions de test avec zones de saisie personnalisées
      async function sendOpenAITestQuestion() {
        const apiKey = document.getElementById('openaiApiKey').value;
        const model = document.getElementById('openaiModel').value;
        const temperature = 0.7; // Température fixe
        const question = document.getElementById('openaiTestInput').value.trim();
        const responseDiv = document.getElementById('openaiTestResponse');
        
        if (!apiKey.trim()) {
          responseDiv.textContent = '❌ ERREUR: Veuillez d\'abord configurer votre clé API OpenAI';
          return;
        }
        
        if (!question) {
          responseDiv.textContent = '❌ ERREUR: Veuillez saisir une question';
          return;
        }
        
        // Dump du début de la requête
        responseDiv.textContent = `🔄 ENVOI EN COURS...\n\n📤 Question envoyée:\n${question}\n\n⏳ Attente de la réponse OpenAI...`;
        
        try {
          const startTime = Date.now();
          const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${apiKey}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              model: model,
              messages: [{ 
                role: 'user', 
                content: question
              }],
              max_tokens: 500,
              temperature: temperature
            })
          });
          
          const endTime = Date.now();
          const duration = endTime - startTime;
          
          if (response.ok) {
            const data = await response.json();
            const reply = data.choices[0].message.content;
            responseDiv.textContent = `✅ SUCCÈS (${duration}ms)\n\n📤 Question:\n${question}\n\n📥 Réponse OpenAI:\n${reply}\n\n📊 Métadonnées:\n- Modèle: ${model}\n- Température: ${temperature}\n- Tokens utilisés: ${data.usage?.total_tokens || 'N/A'}\n- Temps de réponse: ${duration}ms`;
          } else {
            const error = await response.json();
            responseDiv.textContent = `❌ ERREUR HTTP ${response.status} (${duration}ms)\n\n📤 Question:\n${question}\n\n🚨 Erreur:\n${error.error?.message || 'Échec de la requête'}\n\n📊 Détails:\n- Code: ${error.error?.code || 'N/A'}\n- Type: ${error.error?.type || 'N/A'}`;
          }
        } catch (error) {
          responseDiv.textContent = `❌ ERREUR RÉSEAU\n\n📤 Question:\n${question}\n\n🚨 Erreur:\n${error.message}\n\n📊 Détails:\n- Type: ${error.name}\n- Stack: ${error.stack}`;
        }
      }

      async function sendClaudeTestQuestion() {
        const apiKey = document.getElementById('claudeApiKey').value;
        const model = document.getElementById('claudeModel').value;
        const temperature = 0.7; // Température fixe
        const question = document.getElementById('claudeTestInput').value.trim();
        const responseDiv = document.getElementById('claudeTestResponse');
        
        if (!apiKey.trim()) {
          responseDiv.textContent = '❌ ERREUR: Veuillez d\'abord configurer votre clé API Claude';
          return;
        }
        
        if (!question) {
          responseDiv.textContent = '❌ ERREUR: Veuillez saisir une question';
          return;
        }
        
        // Dump du début de la requête
        responseDiv.textContent = `🔄 ENVOI EN COURS...\n\n📤 Question envoyée:\n${question}\n\n⏳ Attente de la réponse Claude...`;
        
        try {
          const startTime = Date.now();
          const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: {
              'x-api-key': apiKey,
              'Content-Type': 'application/json',
              'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify({
              model: model,
              max_tokens: 500,
              temperature: temperature,
              messages: [{ 
                role: 'user', 
                content: question
              }]
            })
          });
          
          const endTime = Date.now();
          const duration = endTime - startTime;
          
          if (response.ok) {
            const data = await response.json();
            const reply = data.content[0].text;
            responseDiv.textContent = `✅ SUCCÈS (${duration}ms)\n\n📤 Question:\n${question}\n\n📥 Réponse Claude:\n${reply}\n\n📊 Métadonnées:\n- Modèle: ${model}\n- Température: ${temperature}\n- Tokens d'entrée: ${data.usage?.input_tokens || 'N/A'}\n- Tokens de sortie: ${data.usage?.output_tokens || 'N/A'}\n- Temps de réponse: ${duration}ms`;
          } else {
            const error = await response.json();
            responseDiv.textContent = `❌ ERREUR HTTP ${response.status} (${duration}ms)\n\n📤 Question:\n${question}\n\n🚨 Erreur:\n${error.error?.message || 'Échec de la requête'}\n\n📊 Détails:\n- Type: ${error.error?.type || 'N/A'}`;
          }
        } catch (error) {
          responseDiv.textContent = `❌ ERREUR RÉSEAU\n\n📤 Question:\n${question}\n\n🚨 Erreur:\n${error.message}\n\n📊 Détails:\n- Type: ${error.name}\n- Stack: ${error.stack}`;
        }
      }

      async function sendMistralTestQuestion() {
        const apiKey = document.getElementById('mistralApiKey').value;
        const model = document.getElementById('mistralModel').value;
        const temperature = 0.7; // Température fixe
        const question = document.getElementById('mistralTestInput').value.trim();
        const responseDiv = document.getElementById('mistralTestResponse');
        
        if (!apiKey.trim()) {
          responseDiv.textContent = '❌ ERREUR: Veuillez d\'abord configurer votre clé API Mistral';
          return;
        }
        
        if (!question) {
          responseDiv.textContent = '❌ ERREUR: Veuillez saisir une question';
          return;
        }
        
        // Préparer les données de la requête
        const requestHeaders = {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        };
        
        const requestBody = {
          model: model,
          messages: [{ 
            role: 'user', 
            content: question
          }],
          max_tokens: 500,
          temperature: temperature
        };
        
        // Afficher la requête web complète au début
        responseDiv.textContent = `🌐 REQUÊTE WEB COMPLÈTE:
        
URL: https://api.mistral.ai/v1/chat/completions
METHOD: POST

HEADERS:
${JSON.stringify(requestHeaders, null, 2)}

BODY:
${JSON.stringify(requestBody, null, 2)}

🔄 ENVOI EN COURS...

📤 Question envoyée:
${question}

⏳ Attente de la réponse Mistral...`;
        
        try {
          const startTime = Date.now();
          const response = await fetch('https://api.mistral.ai/v1/chat/completions', {
            method: 'POST',
            headers: requestHeaders,
            body: JSON.stringify(requestBody)
          });
          
          const endTime = Date.now();
          const duration = endTime - startTime;
          
          if (response.ok) {
            const data = await response.json();
            const reply = data.choices[0].message.content;
            responseDiv.textContent = `🌐 REQUÊTE WEB COMPLÈTE:
        
URL: https://api.mistral.ai/v1/chat/completions
METHOD: POST

HEADERS:
${JSON.stringify(requestHeaders, null, 2)}

BODY:
${JSON.stringify(requestBody, null, 2)}

✅ SUCCÈS (${duration}ms)

📤 Question:
${question}

📥 Réponse Mistral:
${reply}

📊 Métadonnées:
- Modèle: ${model}
- Température: ${temperature}
- Tokens utilisés: ${data.usage?.total_tokens || 'N/A'}
- Temps de réponse: ${duration}ms`;
          } else {
            const error = await response.json();
            responseDiv.textContent = `🌐 REQUÊTE WEB COMPLÈTE:
        
URL: https://api.mistral.ai/v1/chat/completions
METHOD: POST

HEADERS:
${JSON.stringify(requestHeaders, null, 2)}

BODY:
${JSON.stringify(requestBody, null, 2)}

❌ ERREUR HTTP ${response.status} (${duration}ms)

📤 Question:
${question}

🚨 Erreur:
${error.error?.message || 'Échec de la requête'}

📊 Détails:
- Code: ${error.error?.code || 'N/A'}
- Type: ${error.error?.type || 'N/A'}`;
          }
        } catch (error) {
          responseDiv.textContent = `🌐 REQUÊTE WEB COMPLÈTE:
        
URL: https://api.mistral.ai/v1/chat/completions
METHOD: POST

HEADERS:
${JSON.stringify(requestHeaders, null, 2)}

BODY:
${JSON.stringify(requestBody, null, 2)}

❌ ERREUR RÉSEAU

📤 Question:
${question}

🚨 Erreur:
${error.message}

📊 Détails:
- Type: ${error.name}
- Stack: ${error.stack}`;
        }
      }

      document.addEventListener('DOMContentLoaded', function() {
        console.log('🚀 Initialisation des LEDs de l\'interrupteur');
        updateLeds();
        
        // Ajouter event listener sur l'interrupteur pour suivre la boule
        const dataToggle = document.getElementById('dataToggle');
        if (dataToggle) {
          dataToggle.addEventListener('change', function() {
            console.log('🔄 Interrupteur basculé, position:', this.checked ? 'GAUCHE (Scrap)' : 'DROITE (Mock)');
            toggleDataSource();
          });
        }

        // Charger les configurations IA sauvegardées - IMMÉDIATEMENT et aussi plus tard
        loadSavedConfigs();
        
        // Recharger une seconde fois après que tous les éléments soient prêts
        setTimeout(loadSavedConfigs, 1000);
        setTimeout(loadSavedConfigs, 3000);
      });

      // === VARIABLES GLOBALES SQLITE ===
      let sqliteDatabase = null;
      let sqliteInitialized = false;
      let sqliteConnectionInProgress = false;
      
      // === FONCTIONS DUMP/TRACE SQLITE ===
      
      // Ajouter un log dans la section Dump
      function addDumpLog(message, type = 'info') {
        const dumpContent = document.getElementById('sqlite-dump-content');
        if (dumpContent) {
          const timestamp = new Date().toLocaleTimeString();
          let className = '';
          switch(type) {
            case 'error': className = 'style="color: #ff6b6b;"'; break;
            case 'success': className = 'style="color: #51cf66;"'; break;
            case 'warning': className = 'style="color: #ffd43b;"'; break;
            case 'query': className = 'style="color: #74c0fc; font-family: monospace;"'; break;
            case 'result': className = 'style="color: #da77f2;"'; break;
            default: className = 'style="color: #ffffff;"';
          }
          dumpContent.innerHTML += `<div ${className}>[${timestamp}] ${message}</div>`;
          dumpContent.scrollTop = dumpContent.scrollHeight;
        }
        console.log(`🗄️ SQLite Dump: ${message}`);
      }
      
      // Clear le dump
      function clearDumpLog() {
        const dumpContent = document.getElementById('sqlite-dump-content');
        if (dumpContent) {
          dumpContent.innerHTML = `
            <div style="color: #ffff00; margin-bottom: 10px;">📡 SQLite Connection Tracer</div>
            <div>yesdata</div>
            <div style="color: #888; margin-top: 10px;">Logs effacés...</div>
          `;
        }
      }
      
      // === FONCTIONS DE TEST SQLITE ===
      
      // Fonction pour mettre à jour l'état d'une LED de test
      function updateTestLED(testId, state, message = '') {
        const led = document.getElementById(`${testId}-led`);
        const tag = document.getElementById(`${testId}-tag`);
        const dumpContent = document.getElementById('sqlite-dump-content');
        
        if (led && tag) {
          // Retirer toutes les classes d'état
          led.classList.remove('collapsed', 'expanded');
          tag.classList.remove('testing');
          
          switch(state) {
            case 'testing':
              led.style.background = '#ff8800';
              led.style.animation = 'pulse-orange 1s infinite';
              tag.classList.add('testing');
              break;
            case 'success':
              led.classList.add('expanded');
              led.style.animation = '';
              break;
            case 'error':
              led.classList.add('collapsed');
              led.style.background = '#ff4444';
              led.style.animation = '';
              break;
            default:
              led.classList.add('collapsed');
              led.style.animation = '';
          }
        }
        
        // Ajouter message au dump
        if (message && dumpContent) {
          const timestamp = new Date().toLocaleTimeString();
          const logLine = document.createElement('div');
          logLine.style.color = state === 'success' ? '#00ff00' : state === 'error' ? '#ff4444' : '#ffff00';
          logLine.textContent = `[${timestamp}] ${message}`;
          dumpContent.appendChild(logLine);
          
          // Scroll vers le bas
          dumpContent.scrollTop = dumpContent.scrollHeight;
        }
      }
      
      // Test 1: Connexion SQLite
      async function testSQLiteConnection() {
        console.log('🔗 Test connexion SQLite...');
        addDumpLog('🔗 Démarrage test connexion SQLite', 'info');
        updateTestLED('test-connection', 'testing', '🔗 Test connexion SQLite...');
        
        // Vérifier si une connexion est déjà en cours
        if (sqliteConnectionInProgress) {
          addDumpLog('⚠️ Connexion SQLite déjà en cours, attente...', 'warning');
          // Attendre que la connexion en cours se termine
          while (sqliteConnectionInProgress) {
            await new Promise(resolve => setTimeout(resolve, 500));
          }
          if (sqliteInitialized) {
            addDumpLog('✅ Connexion SQLite terminée par autre processus', 'success');
            updateTestLED('test-connection', 'success', '✅ Connexion SQLite: SUCCÈS (réutilisée)');
            return true;
          }
        }
        
        // Si déjà initialisé, ne pas refaire la connexion
        if (sqliteInitialized && sqliteDatabase) {
          addDumpLog('✅ SQLite déjà initialisé', 'success');
          updateTestLED('test-connection', 'success', '✅ Connexion SQLite: SUCCÈS (déjà connecté)');
          return true;
        }
        
        sqliteConnectionInProgress = true;
        addDumpLog('🔒 Verrou connexion SQLite activé', 'info');
        
        try {
          // Vérifier si sql.js est déjà chargé
          if (typeof window.initSqlJs !== 'undefined') {
            addDumpLog('✅ sql.js déjà chargé en mémoire', 'success');
          } else {
            // Charger sql.js depuis CDN avec fallback
            addDumpLog('📦 Chargement sql.js depuis CDN...', 'warning');
            updateTestLED('test-connection', 'testing', '📦 Chargement sql.js...');
            
            // Essayer plusieurs CDN dans l'ordre
            const cdnUrls = [
              'https://sql.js.org/dist/sql-wasm.js',
              'https://unpkg.com/sql.js@1.8.0/dist/sql-wasm.js',
              'https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js'
            ];
            
            let scriptLoaded = false;
            
            for (let i = 0; i < cdnUrls.length && !scriptLoaded; i++) {
              const url = cdnUrls[i];
              addDumpLog(`📡 Tentative CDN ${i + 1}: ${url}`, 'info');
              
              try {
                const script = document.createElement('script');
                script.src = url;
                document.head.appendChild(script);
                
                await new Promise((resolve, reject) => {
                  script.onload = () => {
                    addDumpLog(`✅ sql.js chargé depuis CDN ${i + 1}`, 'success');
                    scriptLoaded = true;
                    resolve();
                  };
                  script.onerror = () => {
                    addDumpLog(`❌ Échec CDN ${i + 1}`, 'warning');
                    reject(new Error(`CDN ${i + 1} failed`));
                  };
                  setTimeout(() => {
                    addDumpLog(`⏰ Timeout CDN ${i + 1} (15s)`, 'warning');
                    reject(new Error(`Timeout CDN ${i + 1}`));
                  }, 15000); // Augmenté à 15s
                });
                break;
              } catch (error) {
                addDumpLog(`⚠️ CDN ${i + 1} échoué: ${error.message}`, 'warning');
                if (i === cdnUrls.length - 1) {
                  addDumpLog('❌ Tous les CDN ont échoué', 'error');
                  throw new Error('Impossible de charger sql.js depuis aucun CDN');
                }
              }
            }
          }
          
          addDumpLog('🔧 Initialisation sql.js...', 'info');
          updateTestLED('test-connection', 'testing', '🔗 Initialisation sql.js...');
          
          // Initialiser sql.js avec configuration appropriée
          const initSqlJs = window.initSqlJs;
          if (!initSqlJs) {
            addDumpLog('❌ initSqlJs non disponible après chargement', 'error');
            throw new Error('initSqlJs non disponible');
          }
          
          addDumpLog('🔧 Configuration sql.js...', 'info');
          const SQL = await initSqlJs({
            locateFile: file => {
              // Utiliser le même domaine que le script chargé
              if (file.endsWith('.wasm')) {
                return `https://sql.js.org/dist/${file}`;
              }
              return file;
            }
          });
          
          // Créer une base de données persistante
          addDumpLog('🗄️ Création base de données persistante...', 'info');
          
          // Tenter de restaurer une sauvegarde existante
          const backup = localStorage.getItem('sqlite_database_backup');
          if (backup) {
            try {
              addDumpLog('📂 Restauration base existante depuis LocalStorage...', 'info');
              const data = JSON.parse(backup);
              const uint8Array = new Uint8Array(data);
              sqliteDatabase = new SQL.Database(uint8Array);
              addDumpLog('✅ Base de données restaurée avec succès', 'success');
            } catch (error) {
              addDumpLog(`⚠️ Erreur restauration: ${error.message}, création nouvelle base`, 'warning');
              sqliteDatabase = new SQL.Database();
            }
          } else {
            addDumpLog('🆕 Aucune sauvegarde trouvée, création nouvelle base', 'info');
            sqliteDatabase = new SQL.Database();
          }
          
          sqliteInitialized = true;
          
          addDumpLog('✅ Base SQLite initialisée avec succès', 'success');
          updateTestLED('test-connection', 'success', '✅ Connexion SQLite: SUCCÈS (sql.js ready)');
          
          sqliteConnectionInProgress = false;
          addDumpLog('🔓 Verrou connexion SQLite libéré', 'info');
          return true;
          
        } catch (error) {
          addDumpLog(`❌ Erreur connexion SQLite: ${error.message}`, 'error');
          addDumpLog('🔄 Basculement en mode LocalStorage pour simulation...', 'warning');
          console.error('Erreur connexion SQLite:', error);
          sqliteInitialized = false;
          
          // Activer le mode fallback
          enableSQLiteFallbackMode();
          
          sqliteConnectionInProgress = false;
          addDumpLog('🔓 Verrou connexion SQLite libéré (erreur)', 'warning');
          updateTestLED('test-connection', 'error', `❌ Connexion SQLite: ÉCHEC - Mode fallback activé`);
          return false;
        }
      }
      
      // Test 2: Base de données
      async function testSQLiteDatabase() {
        console.log('🗄️ Test base de données...');
        updateTestLED('test-database', 'testing', '🗄️ Test création base de données...');
        
        try {
          if (!sqliteInitialized || !sqliteDatabase) {
            throw new Error('SQLite non initialisé - Exécuter d\'abord Test Connexion');
          }
          
          // Vérifier que la base est fonctionnelle
          updateTestLED('test-database', 'testing', '🔍 Vérification base de données...');
          
          const testQuery = sqliteDatabase.exec("SELECT 1 as test");
          if (testQuery.length === 0 || testQuery[0].values[0][0] !== 1) {
            throw new Error('Test de base échoué');
          }
          
          // Base fonctionnelle
          updateTestLED('test-database', 'success', '✅ Base de données: OPÉRATIONNELLE (en mémoire)');
          
        } catch (error) {
          console.error('Erreur base de données:', error);
          updateTestLED('test-database', 'error', `❌ Base de données: ÉCHEC - ${error.message}`);
        }
      }
      
      // Test 3: Tables
      async function testSQLiteTables() {
        console.log('📊 Test création tables...');
        updateTestLED('test-tables', 'testing', '📊 Test création tables...');
        
        try {
          if (!sqliteInitialized || !sqliteDatabase) {
            throw new Error('SQLite non initialisé - Exécuter d\'abord Test Connexion');
          }
          
          updateTestLED('test-tables', 'testing', '🏗️ Création table tirages...');
          
          // Créer table tirages
          const createTiragesSQL = `
            CREATE TABLE IF NOT EXISTS tirages (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              date TEXT NOT NULL UNIQUE,
              numbers TEXT NOT NULL,
              stars TEXT NOT NULL,
              jackpot INTEGER,
              source TEXT DEFAULT 'manual',
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
          `;
          
          sqliteDatabase.run(createTiragesSQL);
          
          updateTestLED('test-tables', 'testing', '🏗️ Création table gains...');
          
          // Créer table gains
          const createGainsSQL = `
            CREATE TABLE IF NOT EXISTS gains (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              tirage_id INTEGER NOT NULL,
              rang INTEGER NOT NULL,
              combinaison TEXT NOT NULL,
              gains INTEGER NOT NULL,
              gagnants INTEGER NOT NULL,
              FOREIGN KEY (tirage_id) REFERENCES tirages(id)
            )
          `;
          
          sqliteDatabase.run(createGainsSQL);
          
          updateTestLED('test-tables', 'testing', '📝 Création index...');
          
          // Créer index pour performances
          sqliteDatabase.run("CREATE INDEX IF NOT EXISTS idx_tirages_date ON tirages(date)");
          sqliteDatabase.run("CREATE INDEX IF NOT EXISTS idx_gains_tirage ON gains(tirage_id)");
          
          // Vérifier que les tables existent
          const tables = sqliteDatabase.exec("SELECT name FROM sqlite_master WHERE type='table'");
          const tableNames = tables[0]?.values.flat() || [];
          
          if (!tableNames.includes('tirages') || !tableNames.includes('gains')) {
            throw new Error('Tables non créées correctement');
          }
          
          updateTestLED('test-tables', 'success', `✅ Tables: CRÉÉES (${tableNames.length} tables: ${tableNames.join(', ')})`);
          
        } catch (error) {
          console.error('Erreur création tables:', error);
          updateTestLED('test-tables', 'error', `❌ Tables: ÉCHEC - ${error.message}`);
        }
      }
      
      // Test 4: Insert données
      async function testSQLiteInsert() {
        console.log('📝 Test insertion données...');
        updateTestLED('test-insert', 'testing', '📝 Test insertion données...');
        
        try {
          if (!sqliteInitialized || !sqliteDatabase) {
            throw new Error('SQLite non initialisé - Exécuter d\'abord Test Connexion');
          }
          
          updateTestLED('test-insert', 'testing', '💾 Insertion tirage test...');
          
          // Données de test
          const testDate = '2025-01-14';
          const testNumbers = '7,15,23,31,47';
          const testStars = '3,8';
          const testJackpot = 125000000;
          
          // Insérer tirage de test
          const insertTirageSQL = `
            INSERT OR REPLACE INTO tirages (date, numbers, stars, jackpot, source)
            VALUES (?, ?, ?, ?, ?)
          `;
          
          sqliteDatabase.run(insertTirageSQL, [testDate, testNumbers, testStars, testJackpot, 'test']);
          
          updateTestLED('test-insert', 'testing', '💰 Insertion gains test...');
          
          // Récupérer l'ID du tirage inséré
          const tirageResult = sqliteDatabase.exec("SELECT id FROM tirages WHERE date = ? LIMIT 1", [testDate]);
          if (tirageResult.length === 0) {
            throw new Error('Tirage test non trouvé après insertion');
          }
          
          const tirageId = tirageResult[0].values[0][0];
          
          // Insérer quelques gains de test
          const insertGainSQL = `
            INSERT INTO gains (tirage_id, rang, combinaison, gains, gagnants)
            VALUES (?, ?, ?, ?, ?)
          `;
          
          const testGains = [
            [tirageId, 1, '5+2', 125000000, 0],
            [tirageId, 2, '5+1', 350000, 3],
            [tirageId, 3, '5+0', 35000, 12],
            [tirageId, 4, '4+2', 2500, 45]
          ];
          
          testGains.forEach(gain => {
            sqliteDatabase.run(insertGainSQL, gain);
          });
          
          // Vérifier les insertions
          const countResult = sqliteDatabase.exec("SELECT COUNT(*) FROM tirages");
          const gainsCountResult = sqliteDatabase.exec("SELECT COUNT(*) FROM gains");
          
          const tiragesCount = countResult[0].values[0][0];
          const gainsCount = gainsCountResult[0].values[0][0];
          
          updateTestLED('test-insert', 'success', `✅ Insert: SUCCÈS (${tiragesCount} tirage, ${gainsCount} gains)`);
          
        } catch (error) {
          console.error('Erreur insertion:', error);
          updateTestLED('test-insert', 'error', `❌ Insert: ÉCHEC - ${error.message}`);
        }
      }
      
      // Test 5: Select données
      async function testSQLiteSelect() {
        console.log('📋 Test sélection données...');
        updateTestLED('test-select', 'testing', '📋 Test sélection données...');
        
        try {
          if (!sqliteInitialized || !sqliteDatabase) {
            throw new Error('SQLite non initialisé - Exécuter d\'abord Test Connexion');
          }
          
          updateTestLED('test-select', 'testing', '🔍 Sélection tirages...');
          
          // Sélectionner tous les tirages
          const tiragesResult = sqliteDatabase.exec(`
            SELECT id, date, numbers, stars, jackpot, source, created_at 
            FROM tirages 
            ORDER BY date DESC
          `);
          
          updateTestLED('test-select', 'testing', '💰 Sélection gains...');
          
          // Sélectionner les gains avec jointure
          const gainsResult = sqliteDatabase.exec(`
            SELECT t.date, g.rang, g.combinaison, g.gains, g.gagnants
            FROM gains g
            JOIN tirages t ON g.tirage_id = t.id
            ORDER BY t.date DESC, g.rang ASC
          `);
          
          // Analyser les résultats
          const tiragesCount = tiragesResult.length > 0 ? tiragesResult[0].values.length : 0;
          const gainsCount = gainsResult.length > 0 ? gainsResult[0].values.length : 0;
          
          if (tiragesCount === 0) {
            throw new Error('Aucun tirage trouvé - Exécuter d\'abord Test Insert');
          }
          
          // Afficher un exemple dans les logs
          if (tiragesResult.length > 0 && tiragesResult[0].values.length > 0) {
            const firstTirage = tiragesResult[0].values[0];
            updateTestLED('test-select', 'testing', `📄 Tirage trouvé: ${firstTirage[1]} - ${firstTirage[2]}+${firstTirage[3]}`);
          }
          
          updateTestLED('test-select', 'success', `✅ Select: SUCCÈS (${tiragesCount} tirages, ${gainsCount} gains)`);
          
        } catch (error) {
          console.error('Erreur sélection:', error);
          updateTestLED('test-select', 'error', `❌ Select: ÉCHEC - ${error.message}`);
        }
      }
      
      // === FONCTION CRÉATION BASE FDJ COMPLÈTE ===
      
      async function createFDJDatabase() {
        console.log('🏗️ Création base FDJ complète...');
        addDumpLog('🏗️ Démarrage création base FDJ complète', 'info');
        updateTestLED('test-database', 'testing', '🏗️ Création base FDJ complète...');
        
        try {
          if (!sqliteInitialized || !sqliteDatabase) {
            addDumpLog('❌ SQLite non initialisé pour création base', 'error');
            throw new Error('SQLite non initialisé - Exécuter d\'abord Test Connexion');
          }
          
          addDumpLog('📋 Création schéma base FDJ...', 'info');
          updateTestLED('test-database', 'testing', '📋 Création schéma base FDJ...');
          
          // 1. Créer toutes les tables avec schéma complet
          const createTablesSQL = `
            -- Table des tirages
            CREATE TABLE IF NOT EXISTS tirages (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              date TEXT NOT NULL UNIQUE,
              numbers TEXT NOT NULL,
              stars TEXT NOT NULL,
              jackpot INTEGER,
              source TEXT DEFAULT 'manual',
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            );

            -- Table des gains par tirage
            CREATE TABLE IF NOT EXISTS gains (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              tirage_id INTEGER NOT NULL,
              rang INTEGER NOT NULL,
              combinaison TEXT NOT NULL,
              gains INTEGER NOT NULL,
              gagnants INTEGER NOT NULL,
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              FOREIGN KEY (tirage_id) REFERENCES tirages(id) ON DELETE CASCADE
            );

            -- Table des sources de données
            CREATE TABLE IF NOT EXISTS sources (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              name TEXT NOT NULL UNIQUE,
              url TEXT,
              active BOOLEAN DEFAULT 1,
              last_sync DATETIME,
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            );

            -- Table de configuration
            CREATE TABLE IF NOT EXISTS config (
              key TEXT PRIMARY KEY,
              value TEXT,
              description TEXT,
              updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            );
          `;
          
          // Exécuter les CREATE TABLE
          addDumpLog('🔧 Exécution requêtes CREATE TABLE...', 'info');
          const statements = createTablesSQL.split(';').filter(sql => sql.trim());
          statements.forEach(sql => {
            if (sql.trim()) {
              addDumpLog(`🔍 SQL: ${sql.trim()}`, 'query');
              sqliteDatabase.run(sql.trim());
              addDumpLog('✅ Requête exécutée avec succès', 'result');
            }
          });
          
          updateTestLED('test-database', 'testing', '📊 Création index de performance...');
          
          // 2. Créer tous les index de performance
          const indexesSQL = [
            "CREATE INDEX IF NOT EXISTS idx_tirages_date ON tirages(date)",
            "CREATE INDEX IF NOT EXISTS idx_tirages_created ON tirages(created_at)",
            "CREATE INDEX IF NOT EXISTS idx_gains_tirage ON gains(tirage_id)",
            "CREATE INDEX IF NOT EXISTS idx_gains_rang ON gains(rang)",
            "CREATE INDEX IF NOT EXISTS idx_sources_active ON sources(active)"
          ];
          
          indexesSQL.forEach(sql => sqliteDatabase.run(sql));
          
          updateTestLED('test-database', 'testing', '🎲 Insertion données de démo...');
          
          // 3. Insérer des sources de données
          const sourcesData = [
            ['EuroMillions Official', 'https://www.fdj.fr/euromillions', 1],
            ['LotteryExtreme', 'https://lotteryextreme.com', 1],
            ['Manual Entry', null, 1]
          ];
          
          sourcesData.forEach(source => {
            sqliteDatabase.run(
              "INSERT OR IGNORE INTO sources (name, url, active) VALUES (?, ?, ?)",
              source
            );
          });
          
          // 4. Insérer configuration par défaut
          const configData = [
            ['app_version', 'V0.002D-SQLite', 'Version actuelle de l\'application'],
            ['scraping_enabled', 'true', 'Activation du scraping automatique'],
            ['default_source', 'EuroMillions Official', 'Source par défaut pour les tirages'],
            ['max_history_days', '365', 'Nombre de jours d\'historique à conserver']
          ];
          
          configData.forEach(config => {
            sqliteDatabase.run(
              "INSERT OR REPLACE INTO config (key, value, description) VALUES (?, ?, ?)",
              config
            );
          });
          
          updateTestLED('test-database', 'testing', '🎯 Insertion tirages de démonstration...');
          
          // 5. Insérer quelques tirages de démonstration
          const demoTirages = [
            ['2025-01-14', '7,15,23,31,47', '3,8', 125000000, 'demo'],
            ['2025-01-11', '12,18,25,33,49', '1,9', 95000000, 'demo'],
            ['2025-01-09', '4,19,27,35,42', '2,7', 75000000, 'demo']
          ];
          
          addDumpLog('🎲 Insertion données tirages démo...', 'info');
          demoTirages.forEach((tirage, index) => {
            addDumpLog(`📊 Insertion tirage ${index + 1}: ${tirage[0]}`, 'info');
            sqliteDatabase.run(
              "INSERT OR REPLACE INTO tirages (date, numbers, stars, jackpot, source) VALUES (?, ?, ?, ?, ?)",
              tirage
            );
            addDumpLog('✅ Tirage inséré', 'result');
          });
          
          // 6. Insérer gains correspondants
          const demoGains = [
            // Gains pour tirage 2025-01-14
            [1, 1, '5+2', 125000000, 0],
            [1, 2, '5+1', 350000, 2],
            [1, 3, '5+0', 35000, 8],
            [1, 4, '4+2', 2500, 15],
            [1, 5, '4+1', 150, 287],
            
            // Gains pour tirage 2025-01-11
            [2, 1, '5+2', 95000000, 1],
            [2, 2, '5+1', 280000, 3],
            [2, 3, '5+0', 28000, 12],
            [2, 4, '4+2', 2200, 18],
            
            // Gains pour tirage 2025-01-09
            [3, 1, '5+2', 75000000, 0],
            [3, 2, '5+1', 420000, 1],
            [3, 3, '5+0', 42000, 6],
            [3, 4, '4+2', 3000, 12]
          ];
          
          addDumpLog('💰 Insertion données gains démo...', 'info');
          demoGains.forEach((gain, index) => {
            addDumpLog(`💰 Insertion gain ${index + 1}: tirage_id=${gain[0]}, comb=${gain[2]}`, 'info');
            sqliteDatabase.run(
              "INSERT OR REPLACE INTO gains (tirage_id, rang, combinaison, gains, gagnants) VALUES (?, ?, ?, ?, ?)",
              gain
            );
            addDumpLog('✅ Gain inséré', 'result');
          });
          
          updateTestLED('test-database', 'testing', '✅ Vérification intégrité base...');
          
          // 7. Vérifications finales
          addDumpLog('🔍 Vérifications finales de la base...', 'info');
          const tables = sqliteDatabase.exec("SELECT name FROM sqlite_master WHERE type='table'");
          const tableCount = tables[0]?.values.length || 0;
          addDumpLog(`📊 ${tableCount} tables créées`, 'result');
          
          const tiragesCount = sqliteDatabase.exec("SELECT COUNT(*) FROM tirages")[0].values[0][0];
          addDumpLog(`🎲 ${tiragesCount} tirages insérés`, 'result');
          
          const gainsCount = sqliteDatabase.exec("SELECT COUNT(*) FROM gains")[0].values[0][0];
          addDumpLog(`💰 ${gainsCount} gains insérés`, 'result');
          
          const sourcesCount = sqliteDatabase.exec("SELECT COUNT(*) FROM sources")[0].values[0][0];
          addDumpLog(`🔗 ${sourcesCount} sources insérées`, 'result');
          
          const configCount = sqliteDatabase.exec("SELECT COUNT(*) FROM config")[0].values[0][0];
          addDumpLog(`⚙️ ${configCount} paramètres de config insérés`, 'result');
          
          addDumpLog('🎉 Base FDJ créée avec succès !', 'success');
          
          // Sauvegarder automatiquement la nouvelle base
          addDumpLog('💾 Sauvegarde automatique de la base...', 'info');
          saveSQLiteDatabase();
          
          updateTestLED('test-database', 'success', 
            `✅ Base FDJ CRÉÉE ! ${tableCount} tables, ${tiragesCount} tirages, ${gainsCount} gains, ${sourcesCount} sources, ${configCount} configs`
          );
          
        } catch (error) {
          addDumpLog(`❌ ERREUR création base FDJ: ${error.message}`, 'error');
          console.error('Erreur création base FDJ:', error);
          updateTestLED('test-database', 'error', `❌ Création base FDJ: ÉCHEC - ${error.message}`);
        }
      }
      
      // === FONCTIONS MONITORING AUTONOME ===
      
      // Fonction de monitoring autonome SQLite
      async function autonomousTableMonitoring(tableName) {
        if (!tableName) {
          clearMonitoringDisplay('sqlite');
          return;
        }
        
        console.log(`🔍 Démarrage monitoring autonome SQLite pour table: ${tableName}`);
        showAutoStatus('sqlite', '🔍 Initialisation du monitoring autonome...', 'info');
        
        try {
          // 1. Vérifier et initialiser SQLite si nécessaire
          if (!sqliteInitialized) {
            showAutoStatus('sqlite', '🔗 SQLite non initialisé, tentative de connexion...', 'warning');
            await testSQLiteConnection();
            
            if (!sqliteInitialized) {
              showAutoStatus('sqlite', '❌ Impossible de se connecter à SQLite', 'error');
              return;
            }
          }
          
          // 2. Vérifier l'état de la base et debug
          showAutoStatus('sqlite', '🗄️ Vérification de la base de données...', 'info');
          
          // Debug: Lister toutes les tables existantes
          const allTables = await debugSQLiteTables();
          console.log('📋 Tables SQLite existantes:', allTables);
          showAutoStatus('sqlite', `📋 Tables trouvées: ${allTables.join(', ')}`, 'info');
          
          // 3. Vérifier l'existence de la table
          showAutoStatus('sqlite', `📊 Vérification de la table ${tableName}...`, 'info');
          const tableExists = await verifyTableExists(tableName);
          
          if (!tableExists) {
            showAutoStatus('sqlite', `⚠️ Table ${tableName} non trouvée, création automatique...`, 'warning');
            await createMissingTable(tableName);
          }
          
          // 4. Debug: Compter les enregistrements
          const recordCount = await debugTableRecordCount(tableName);
          console.log(`📊 Table ${tableName}: ${recordCount} enregistrements`);
          showAutoStatus('sqlite', `📊 Table ${tableName}: ${recordCount} enregistrements`, 'info');
          
          // 5. Charger les données avec retry
          showAutoStatus('sqlite', `📋 Chargement des données de ${tableName}...`, 'info');
          const loadResult = await loadSQLiteTableDataWithRetry();
          
          if (loadResult) {
            showAutoStatus('sqlite', `✅ Monitoring ${tableName} opérationnel`, 'success');
          } else {
            showAutoStatus('sqlite', `⚠️ Monitoring ${tableName} - données vides`, 'warning');
          }
          
          setTimeout(() => hideAutoStatus('sqlite'), 5000);
          
        } catch (error) {
          console.error('Erreur monitoring autonome SQLite:', error);
          showAutoStatus('sqlite', `❌ Erreur: ${error.message}`, 'error');
        }
      }
      

      
      // Fonctions utilitaires pour le monitoring autonome
      function showAutoStatus(type, message, level) {
        const statusDiv = document.getElementById(`${type}-auto-status`);
        const logsDiv = document.getElementById(`${type}-auto-logs`);
        
        if (!statusDiv || !logsDiv) return;
        
        const timestamp = new Date().toLocaleTimeString();
        const colors = {
          info: '#3b82f6',
          success: '#22c55e', 
          warning: '#f59e0b',
          error: '#ef4444'
        };
        
        logsDiv.innerHTML = `
          <div style="color: ${colors[level] || '#888'}; font-size: 0.9em;">
            [${timestamp}] ${message}
          </div>
        `;
        
        statusDiv.style.display = 'block';
      }
      
      function hideAutoStatus(type) {
        const statusDiv = document.getElementById(`${type}-auto-status`);
        if (statusDiv) {
          statusDiv.style.display = 'none';
        }
      }
      
      function clearMonitoringDisplay(type) {
        const statsDiv = document.getElementById(`${type}-monitoring-stats`);
        const tableDiv = document.getElementById(`${type}-monitoring-table`);
        const paginationDiv = document.getElementById(`${type}-monitoring-pagination`);
        
        if (statsDiv) statsDiv.innerHTML = '';
        if (tableDiv) tableDiv.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">Sélectionnez une table pour démarrer le monitoring autonome.</p>';
        if (paginationDiv) paginationDiv.innerHTML = '';
        
        hideAutoStatus(type);
      }
      
      // Vérification de l'existence d'une table SQLite
      async function verifyTableExists(tableName) {
        if (!sqliteInitialized || !sqliteDatabase) return false;
        
        try {
          const result = sqliteDatabase.exec(`SELECT name FROM sqlite_master WHERE type='table' AND name='${tableName}'`);
          return result.length > 0 && result[0].values.length > 0;
        } catch (error) {
          console.warn(`Erreur vérification table ${tableName}:`, error);
          return false;
        }
      }
      
      // Création automatique d'une table manquante
      async function createMissingTable(tableName) {
        if (!sqliteInitialized || !sqliteDatabase) {
          throw new Error('SQLite non initialisé');
        }
        
        const tableSchemas = {
          tirages: `CREATE TABLE IF NOT EXISTS tirages (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            date TEXT UNIQUE NOT NULL,
            numbers TEXT NOT NULL,
            stars TEXT NOT NULL,
            jackpot INTEGER DEFAULT 0,
            source TEXT DEFAULT 'auto',
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
          )`,
          gains: `CREATE TABLE IF NOT EXISTS gains (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            tirage_id INTEGER NOT NULL,
            rang INTEGER NOT NULL,
            combinaison TEXT NOT NULL,
            gains INTEGER NOT NULL,
            gagnants INTEGER NOT NULL,
            FOREIGN KEY (tirage_id) REFERENCES tirages(id) ON DELETE CASCADE
          )`,
          sources: `CREATE TABLE IF NOT EXISTS sources (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            nom TEXT UNIQUE NOT NULL,
            url TEXT,
            actif BOOLEAN DEFAULT 1,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
          )`,
          config: `CREATE TABLE IF NOT EXISTS config (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            cle TEXT UNIQUE NOT NULL,
            valeur TEXT NOT NULL,
            description TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
          )`
        };
        
        if (!tableSchemas[tableName]) {
          throw new Error(`Schéma inconnu pour la table: ${tableName}`);
        }
        
        try {
          sqliteDatabase.run(tableSchemas[tableName]);
          console.log(`✅ Table ${tableName} créée automatiquement`);
        } catch (error) {
          throw new Error(`Erreur création table ${tableName}: ${error.message}`);
        }
      }
      

      
      // === MODE FALLBACK SQLITE ===
      
      let sqliteFallbackMode = false;
      
      // Activer le mode fallback LocalStorage
      function enableSQLiteFallbackMode() {
        sqliteFallbackMode = true;
        addDumpLog('🔄 Mode fallback SQLite activé (simulation avec LocalStorage)', 'warning');
        
        // Créer des données de démo en LocalStorage pour simulation
        const demoData = {
          'sqlite_tirages': [
            { id: 1, date: '2025-01-14', numbers: '7,15,23,31,47', stars: '3,8', jackpot: 125000000, source: 'demo' },
            { id: 2, date: '2025-01-11', numbers: '12,18,25,33,49', stars: '1,9', jackpot: 95000000, source: 'demo' },
            { id: 3, date: '2025-01-09', numbers: '4,19,27,35,42', stars: '2,7', jackpot: 75000000, source: 'demo' }
          ],
          'sqlite_gains': [
            { id: 1, tirage_id: 1, rang: 1, combinaison: '5+2', gains: 125000000, gagnants: 0 },
            { id: 2, tirage_id: 1, rang: 2, combinaison: '5+1', gains: 350000, gagnants: 2 },
            { id: 3, tirage_id: 1, rang: 3, combinaison: '5+0', gains: 35000, gagnants: 8 },
            { id: 4, tirage_id: 2, rang: 1, combinaison: '5+2', gains: 95000000, gagnants: 1 },
            { id: 5, tirage_id: 2, rang: 2, combinaison: '5+1', gains: 280000, gagnants: 3 }
          ],
          'sqlite_sources': [
            { id: 1, nom: 'FDJ Officiel', url: 'https://www.fdj.fr', actif: 1 },
            { id: 2, nom: 'Demo Source', url: 'http://demo.local', actif: 1 }
          ],
          'sqlite_config': [
            { id: 1, cle: 'app_version', valeur: 'V0.001E', description: 'Version application' },
            { id: 2, cle: 'last_update', valeur: '2025-01-14', description: 'Dernière mise à jour' }
          ]
        };
        
        Object.keys(demoData).forEach(key => {
          localStorage.setItem(key, JSON.stringify(demoData[key]));
          addDumpLog(`💾 Données ${key} sauvées en LocalStorage`, 'info');
        });
        
        addDumpLog('✅ Mode fallback prêt avec données démo', 'success');
      }
      
      // Récupérer données en mode fallback (LocalStorage)
      function getSQLiteFallbackData(tableType) {
        addDumpLog(`🔄 Mode fallback: récupération ${tableType}`, 'warning');
        
        try {
          let key = '';
          switch(tableType) {
            case 'tirages':
              key = 'sqlite_tirages';
              break;
            case 'gains':
              key = 'sqlite_gains';
              break;
            case 'sources':
              key = 'sqlite_sources';
              break;
            case 'config':
              key = 'sqlite_config';
              break;
            case 'all':
              // Retourner toutes les données combinées
              const allData = [];
              ['sqlite_tirages', 'sqlite_gains', 'sqlite_sources', 'sqlite_config'].forEach(k => {
                const data = JSON.parse(localStorage.getItem(k) || '[]');
                allData.push(...data.map(item => ({ ...item, type: k.replace('sqlite_', '') })));
              });
              addDumpLog(`🔄 Fallback: ${allData.length} items de toutes les tables`, 'result');
              return allData;
            default:
              addDumpLog(`❌ Fallback: type ${tableType} non supporté`, 'error');
              return [];
          }
          
          const data = JSON.parse(localStorage.getItem(key) || '[]');
          addDumpLog(`🔄 Fallback: ${data.length} items de ${tableType}`, 'result');
          
          // Ajouter le type pour l'affichage
          return data.map(item => ({ ...item, type: tableType === 'gains' ? 'gain' : tableType }));
          
        } catch (error) {
          addDumpLog(`❌ Erreur fallback ${tableType}: ${error.message}`, 'error');
          return [];
        }
      }
      
      // === PERSISTANCE SQLITE ===
      
      // Sauvegarder la base SQLite dans LocalStorage
      function saveSQLiteDatabase() {
        if (!sqliteInitialized || !sqliteDatabase) {
          addDumpLog('⚠️ Impossible de sauvegarder: SQLite non initialisé', 'warning');
          return false;
        }
        
        try {
          addDumpLog('💾 Sauvegarde base SQLite...', 'info');
          const data = sqliteDatabase.export();
          const dataArray = Array.from(data);
          localStorage.setItem('sqlite_database_backup', JSON.stringify(dataArray));
          addDumpLog(`✅ Base sauvegardée (${dataArray.length} bytes)`, 'success');
          return true;
        } catch (error) {
          addDumpLog(`❌ Erreur sauvegarde: ${error.message}`, 'error');
          return false;
        }
      }
      
      // Sauvegarder automatiquement après modification
      function autoSaveSQLiteDatabase() {
        // Sauvegarder avec un petit délai pour éviter les sauvegardes trop fréquentes
        if (window.sqliteAutoSaveTimeout) {
          clearTimeout(window.sqliteAutoSaveTimeout);
        }
        window.sqliteAutoSaveTimeout = setTimeout(() => {
          saveSQLiteDatabase();
        }, 1000); // Sauvegarde 1 seconde après la dernière modification
      }
      
      // Effacer la sauvegarde
      function clearSQLiteBackup() {
        localStorage.removeItem('sqlite_database_backup');
        addDumpLog('🗑️ Sauvegarde SQLite effacée', 'warning');
      }
      
      // === FONCTIONS DEBUG SQLITE ===
      
      // Debug: Lister toutes les tables SQLite
      async function debugSQLiteTables() {
        addDumpLog('🔍 Debug: Listage de toutes les tables', 'info');
        
        if (!sqliteInitialized || !sqliteDatabase) {
          addDumpLog('❌ SQLite non initialisé pour debug tables', 'error');
          return [];
        }
        
        try {
          const query = "SELECT name FROM sqlite_master WHERE type='table'";
          addDumpLog(`🔍 Debug query: ${query}`, 'query');
          const result = sqliteDatabase.exec(query);
          
          if (result.length === 0) {
            addDumpLog('⚠️ Aucune table trouvée dans la base', 'warning');
            return [];
          }
          
          const tables = result[0].values.map(row => row[0]);
          addDumpLog(`✅ Tables trouvées: [${tables.join(', ')}]`, 'result');
          return tables;
        } catch (error) {
          addDumpLog(`❌ Erreur debug tables: ${error.message}`, 'error');
          console.error('Erreur debug tables:', error);
          return [];
        }
      }
      
      // Debug: Compter les enregistrements d'une table
      async function debugTableRecordCount(tableName) {
        addDumpLog(`🔢 Debug: Comptage enregistrements table ${tableName}`, 'info');
        
        if (!sqliteInitialized || !sqliteDatabase) {
          addDumpLog('❌ SQLite non initialisé pour comptage', 'error');
          return 0;
        }
        
        try {
          const query = `SELECT COUNT(*) FROM ${tableName}`;
          addDumpLog(`🔍 Count query: ${query}`, 'query');
          const result = sqliteDatabase.exec(query);
          
          if (result.length === 0) {
            addDumpLog(`⚠️ Aucun résultat pour comptage ${tableName}`, 'warning');
            return 0;
          }
          
          const count = result[0].values[0][0];
          addDumpLog(`✅ Table ${tableName}: ${count} enregistrements`, 'result');
          return count;
        } catch (error) {
          addDumpLog(`❌ Erreur comptage ${tableName}: ${error.message}`, 'error');
          console.error(`Erreur comptage ${tableName}:`, error);
          return 0;
        }
      }
      
      // Chargement SQLite avec retry et debug
      async function loadSQLiteTableDataWithRetry() {
        try {
          const tableSelector = document.getElementById('sqliteTableSelector');
          if (!tableSelector || !tableSelector.value) {
            console.warn('Pas de table sélectionnée');
            return false;
          }
          
          console.log(`🔄 Tentative chargement table: ${tableSelector.value}`);
          
          // Appeler la fonction de chargement existante
          loadSQLiteTableData();
          
          // Vérifier si des données ont été chargées
          const monitoringTable = document.getElementById('sqlite-monitoring-table');
          if (monitoringTable && monitoringTable.innerHTML.includes('Base SQLite vide')) {
            console.warn('Aucune donnée chargée - table vide');
            return false;
          }
          
          return true;
        } catch (error) {
          console.error('Erreur chargement avec retry:', error);
          return false;
        }
      }
      
      // === AUTO-INITIALISATION MONITORING ===
      
      // Fonction d'initialisation automatique du monitoring
      async function autoInitializeMonitoring() {
        console.log('🚀 Auto-initialisation du monitoring...');
        
        try {
          // 1. Définir la table par défaut pour SQLite
          const sqliteSelector = document.getElementById('sqliteTableSelector');
          if (sqliteSelector && !sqliteSelector.value) {
            sqliteSelector.value = 'tirages'; // Table par défaut
            console.log('📋 Table par défaut SQLite: tirages');
          }
          

          
          // 2. Tester SQLite automatiquement et charger les données
          if (sqliteSelector && sqliteSelector.value) {
            console.log('🔄 Démarrage monitoring autonome SQLite...');
            await autonomousTableMonitoring(sqliteSelector.value);
          }
          

          
          console.log('✅ Auto-initialisation terminée');
          
        } catch (error) {
          console.error('❌ Erreur auto-initialisation:', error);
        }
      }
      
      // === FONCTIONS INSTALL FROM SCRATCH ===
      
      // Fonction pour ajouter logs d'installation
      function addInstallLog(message, type = 'info') {
        const logsContent = document.getElementById('install-logs-content');
        const timestamp = new Date().toLocaleTimeString();
        
        const logEntry = document.createElement('div');
        logEntry.style.marginBottom = '5px';
        
        switch(type) {
          case 'success':
            logEntry.style.color = '#22c55e';
            break;
          case 'error':
            logEntry.style.color = '#ef4444';
            break;
          case 'warning':
            logEntry.style.color = '#f59e0b';
            break;
          default:
            logEntry.style.color = '#94a3b8';
        }
        
        logEntry.textContent = `[${timestamp}] ${message}`;
        logsContent.appendChild(logEntry);
        
        // Auto-scroll vers le bas
        logsContent.scrollTop = logsContent.scrollHeight;
      }
      
      // Fonction 1: Supprimer base
      async function deleteDatabase() {
        console.log('🗑️ Suppression base de données...');
        addInstallLog('🗑️ Début suppression base de données...', 'warning');
        
        try {
          if (!sqliteInitialized || !sqliteDatabase) {
            addInstallLog('❌ SQLite non initialisé - rien à supprimer', 'error');
            return;
          }
          
          addInstallLog('📋 Suppression des tables...', 'info');
          
          // Supprimer toutes les tables
          const tables = ['gains', 'tirages', 'sources', 'config'];
          tables.forEach(table => {
            try {
              sqliteDatabase.run(`DROP TABLE IF EXISTS ${table}`);
              addInstallLog(`✅ Table ${table} supprimée`, 'success');
            } catch (error) {
              addInstallLog(`⚠️ Erreur suppression ${table}: ${error.message}`, 'warning');
            }
          });
          
          // Supprimer les index
          const indexes = ['idx_tirages_date', 'idx_tirages_created', 'idx_gains_tirage', 'idx_gains_rang', 'idx_sources_active'];
          indexes.forEach(index => {
            try {
              sqliteDatabase.run(`DROP INDEX IF EXISTS ${index}`);
            } catch (error) {
              // Ignorer les erreurs d'index (normal si n'existe pas)
            }
          });
          
          addInstallLog('✅ Base de données supprimée avec succès !', 'success');
          
        } catch (error) {
          console.error('Erreur suppression base:', error);
          addInstallLog(`❌ Erreur suppression: ${error.message}`, 'error');
        }
      }
      
      // Fonction 2: Installation complète
      async function installFreshDatabase() {
        console.log('🏗️ Installation complète base FDJ...');
        addInstallLog('🏗️ Début installation complète...', 'info');
        
        try {
          // 1. Vérifier/Initialiser connexion SQLite
          addInstallLog('🔗 Vérification connexion SQLite...', 'info');
          if (!sqliteInitialized || !sqliteDatabase) {
            addInstallLog('🔌 Initialisation connexion SQLite...', 'info');
            await testSQLiteConnection();
            
            // Attendre un peu que la connexion soit établie
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            if (!sqliteInitialized || !sqliteDatabase) {
              throw new Error('Impossible d\'initialiser la connexion SQLite');
            }
            addInstallLog('✅ Connexion SQLite établie', 'success');
          } else {
            addInstallLog('✅ Connexion SQLite déjà active', 'success');
          }
          
          // 2. Supprimer base existante
          addInstallLog('🗑️ Suppression base existante...', 'warning');
          await deleteDatabase();
          
          await new Promise(resolve => setTimeout(resolve, 500)); // Pause visuelle
          
          // 3. Créer la base FDJ complète
          addInstallLog('🏗️ Création nouvelle base FDJ...', 'info');
          await createFDJDatabase();
          
          addInstallLog('🎉 Installation complète terminée avec succès !', 'success');
          addInstallLog('📊 Vous pouvez maintenant utiliser les sections de monitoring', 'info');
          
        } catch (error) {
          console.error('Erreur installation complète:', error);
          addInstallLog(`❌ Erreur installation: ${error.message}`, 'error');
        }
      }
      
      // Fonction 3: Vérifier état de la base
      async function checkDatabaseStatus() {
        console.log('📊 Vérification état base...');
        addInstallLog('📊 Vérification état de la base...', 'info');
        
        try {
          if (!sqliteInitialized || !sqliteDatabase) {
            addInstallLog('❌ SQLite non initialisé - Utilisez "Test Connexion" d\'abord', 'error');
            addInstallLog('💡 Étapes: 1️⃣ Test Connexion → 2️⃣ Installation Complète', 'info');
            return;
          }
          
          addInstallLog('✅ SQLite initialisé et connecté', 'success');
          
          // Vérifier les tables existantes
          const tablesResult = sqliteDatabase.exec("SELECT name FROM sqlite_master WHERE type='table'");
          const tables = tablesResult.length > 0 ? tablesResult[0].values.flat() : [];
          
          addInstallLog(`📋 Tables trouvées: ${tables.length}`, 'info');
          tables.forEach(table => {
            addInstallLog(`  - ${table}`, 'info');
          });
          
          // Compter les données dans chaque table
          if (tables.includes('tirages')) {
            const tiragesCount = sqliteDatabase.exec("SELECT COUNT(*) FROM tirages")[0].values[0][0];
            addInstallLog(`📊 Tirages: ${tiragesCount} enregistrements`, 'success');
          }
          
          if (tables.includes('gains')) {
            const gainsCount = sqliteDatabase.exec("SELECT COUNT(*) FROM gains")[0].values[0][0];
            addInstallLog(`💰 Gains: ${gainsCount} enregistrements`, 'success');
          }
          
          if (tables.includes('sources')) {
            const sourcesCount = sqliteDatabase.exec("SELECT COUNT(*) FROM sources")[0].values[0][0];
            addInstallLog(`🔗 Sources: ${sourcesCount} enregistrements`, 'success');
          }
          
          if (tables.includes('config')) {
            const configCount = sqliteDatabase.exec("SELECT COUNT(*) FROM config")[0].values[0][0];
            addInstallLog(`⚙️ Configuration: ${configCount} paramètres`, 'success');
          }
          
          if (tables.length === 0) {
            addInstallLog('⚠️ Aucune table trouvée - Base vide', 'warning');
            addInstallLog('💡 Utilisez "Installation Complète" pour créer la base', 'info');
          } else {
            addInstallLog('✅ Base de données opérationnelle !', 'success');
          }
          
          addInstallLog('ℹ️ INFO: Base SQLite en MÉMOIRE (volatile)', 'info');
          addInstallLog('ℹ️ Les données sont perdues à la fermeture du navigateur', 'info');
          
        } catch (error) {
          console.error('Erreur vérification état:', error);
          addInstallLog(`❌ Erreur vérification: ${error.message}`, 'error');
        }
      }

    </script>
  </body>
</html>
